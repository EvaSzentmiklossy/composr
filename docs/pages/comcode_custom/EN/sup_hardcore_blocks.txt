[title sub="Written by Chris Warburton, ocProducts"]Composr Supplementary: Coding blocks[/title]

[contents]decimal,lower-alpha[/contents]

[title="2"]Creating mini-blocks from Third-Party Code[/title]

This is a short example-driven tutorial on creating a new Composr block (actually a "mini-block") by using externally-provided code. This is a great way to get started with customising Composr to your needs, and providing some level of integration between your Composr installation and your favourite external Web sites.

[title="3"]Who Is This Aimed At?[/title]

 - Those with little to no programming experience, but with a willingness to learn
 - Composr Web masters who want a little more integration with their favourite sites and services
 - Programmers wanting to learn how to code for Composr

[title="3"]What You'll Achieve[/title]

 - Learn a little about the languages which drive Composr and the Web in general:
  - PHP
  - Javascript
  - CSS
  - HTML
 - Learn how to integrate existing code into Composr in a basic way
 - A new block which you can insert into any Comcode-enabled field on your Composr site
 - An addon to share with the Composr community

[title="3"]What You'll Need[/title]

 - A text editor, preferably one aimed at programmers. A word processor will not do, and neither will Windows Notepad (if you try to use Notepad it will cause you lots of headaches later!). Examples of good programming text editors are:
  - [url="http://en.wikipedia.org/wiki/JEdit" target="_blank"]jEdit[/url] (Linux, Windows, Mac OSX)
  - [url="http://en.wikipedia.org/wiki/Geany" target="_blank"]Geany[/url] (Linux, Windows, Mac OSX)
  - [url="http://en.wikipedia.org/wiki/Kate_%28text_editor%29" target="_blank"]Kate[/url] (Linux, Windows, Mac OSX)
  - [url="http://en.wikipedia.org/wiki/KWrite" target="_blank"]KWrite[/url] (Linux, Windows, Mac OSX)
  - [url="http://en.wikipedia.org/wiki/Metapad" target="_blank"]MetaPad[/url] (Windows)
  - [url="http://en.wikipedia.org/wiki/Notepad%2B%2B" target="_blank"]Notepad++[/url] (Windows)
  - [url="http://en.wikipedia.org/wiki/Notepad2" target="_blank"]Notepad2[/url] (Windows)
 - A working Composr installation (see the [page="docs:tutorials"]Composr documentation[/page] on how to get up and running). This doesn't necessarily have to be a live Web site, for example it could be installed on your home computer and only accessible to your home network.
 - Some HTML you would like to reference from inside Composr. Usually you can find lots of examples of this kind of thing under names like "embed code", "blog widget" and that kind of thing. It should be in the [url="http://en.wikipedia.org/wiki/HTML" target="_blank"]HTML[/url] format. For this example I'm using some code from the [url="http://www.osm.org" target="_blank"]OpenStreetMap project[/url], which I'll describe below.

[title="3"]Getting Started[/title]

In this example we're going to create a Composr "mini-block" out of the following code: [code="html"]<iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="http://www.openstreetmap.org/export/embed.html?bbox=-1.49107,53.37746,-1.48328,53.38272&amp;layer=mapnik" style="border: 1px solid black"></iframe><br /><small><a href="http://www.openstreetmap.org/?lat=53.38009&amp;lon=-1.487175&amp;zoom=16&amp;layers=M">View Larger Map</a></small>[/code]
 . This is taken from the [url="http://www.osm.org" target="_blank"]OpenStreetMap[/url] site, and in this particular case shows a map of the main campus of the University of Sheffield. To get this code I clicked on the "Export" tab at the top of the map and chose "Embeddable HTML". The code appeared in the text box labelled "output". Lots of sites offer code like this, and the purpose of this tutorial is to make accessing such snippets of code really easy for users of our Composr sites.

[title="3"]What is a mini-block?[/title]

"Mini-blocks" are a simpler form of Composr's "blocks". On a Composr-powered site, the majority of the content (page content, forum posts, comments, etc.) is written as straightforward text. To give extra control over how this text will be displayed, the [url="http://compo.sr/docs/tut_comcode.htm"]Comcode language[/url] can be used to specify things like "I want this text to be bold" or "I want this to be a link" or "I want this image here". To get even more power, a programmer can write some specific bits of functionality to display (usually) in a box, which Comcode writers can then embed in the content they write, in much the same way as an image can be embedded. These are called "blocks", and they have lots of useful features (like caching, to reduce the server load; parameters, to give them options,; etc.). A "mini-block" provides the same drop-in usage for Comcode users, but without some of the fancy extras that regular blocks have. This sacrifice makes them much easier to write.

[title="3"]Preparing To Make Our mini-block[/title]

A mini-block is written in the PHP language, a programming language which uses "plain" text files for storing its programs. We'll get to the contents of the file in a moment, but to tell Composr that a text file contains some PHP, we give the file a name that ends in ".php" (rather than, for example, ".txt" which is often used for "plain" text files). For Composr to find the mini-block we need to put the file inside a folder called "mini-blocks" inside the "sources_custom" folder at the location that you've installed Composr to. The final thing we need to know is the actual name of the file. This is up to you, but the convention is that blocks which are intended to be used in a large area, like the middle of a page, start with "main_", whilst those intended for use in side panels have file names starting with "side_". Whatever comes afterwards, up to the ".php", is up to you, but try to stick to English letters without accents, since other letters and characters may confuse some systems. For this example I will call our mini-block "main_openstreetmap.php", so we need to make a new, empty text file inside the programming editor and save it as "main_openstreetmap.php" inside the "mini-blocks" folder inside the "sources_custom" folder of the Composr installation. If you don't have direct access to your Composr system, for example if you can only manage the files from a Web interface, FTP or similar then you can simply save it to the drive on whichever computer you're using then upload it to your site when you're finished; though this can be a little tedious if you have to keep making small fixes and changes.

[title="3"]What to Put in the mini-block?[/title]

With your empty PHP text file open in your programming editor, you can begin to write the mini-block. Due to the nature of PHP, as it was originally created to embed inside HTML files, the first thing we need to do is declare that we're going to start writing some PHP in our file. We do this by writing the following at the start of the file:
[code="php"]<?php[/code]
The next thing we should do is to write a short description of what we're about to do, so that we don't get confused by the code later. Such descriptions are called "comments", and we write a comment by telling PHP to ignore what we're about to say (otherwise it may get confused and try to run our sentences as if they were code). There are 2 ways to do this in PHP. The first is to write two slashes, followed by our comment, like this:
[code="php"]// This is my comment. PHP will ignore it.[/code]
 PHP will ignore whatever is written after 2 slashes until the end of that line. If you want to write a comment which takes up several lines then you can either put 2 slashes at the start of each line, or you can put a slash followed by an asterisk to start the comment, and an asterisk followed by a slash to end it, like this
[code="php"]/* This is a comment. It carries on for as long as I want it to. Even this is still a comment. I can end it like this */ [/code]
Using this notation we can put a description at the top of our mini-block, to make our mini-block look like this so far:
[code="php"]<?php
/* This is a miniblock to draw a map from OpenStreetMap.org.
It centres on the University of Sheffield by default. */
[/code]
The next thing to do is to tell PHP what we want it to output. PHP is an elaborate text-rewriting system which, as it runs, gives out data. The data we want it to give out is text in the HTML format, so that visitors to our site will be able to display it in their Web browsers. The exact text we want it to give out is the code we obtained from OpenStreetMap.org. Thus we first tell PHP that we want it to output something, which we do by using the "echo" command:

[code="php"]<?php
/* This is a miniblock to draw a map from OpenStreetMap.org.
It centres on the University of Sheffield by default. */
echo [/code]
Then, after a space, we say what we would like to have it output; the classic example being
[code="php"]echo "hello world"[/code]
 Note that we can't just dump our HTML into the PHP, as PHP files allow HTML to be mixed in with the PHP, which will confuse the program. Instead we need to explicitly tell it that the HTML is a piece of text, and not something that it should try to run. We do this by quoting the text, which can be done with either single quotes 'like this' or double quotes "like this". Since our HTML contains some double quotes, and "quotes can't be "nested"" (unlike brackets (which can)) we should use single quotes. To end the echo statement we need to use a semicolon ; outside of any quotes. Thus our mini-block looks like this:
[code="php"]<?php
/* This is a miniblock to draw a map from OpenStreetMap.org.
It centres on the University of Sheffield by default. */
echo '<iframe width="425" height="350" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="http://www.openstreetmap.org/export/embed.html?bbox=-1.4911,53.37756,-1.48325,53.38262&amp;layer=mapnik" style="border: 1px solid black"></iframe><br /><small><a href="http://www.openstreetmap.org/?lat=53.38009&amp;lon=-1.487175&amp;zoom=16&amp;layers=M">View Larger Map</a></small>';[/code]
 This suddenly looks a lot more complicated, but as far as PHP is concerned this is as simple as the 'echo "hello world";' example. It doesn't care whether the text is written in HTML or not, it's only the user's browser that cares. Also, keep in mind that all of the above HTML was copied straight from someone else's Web site/service, we didn't have to write it and we don't even need to care how it works (although some parts like "height", "lat", "lon" and "zoom" are pretty easy to guess).

[title="3"]Using the mini-block[/title]

That's all there is to writing a mini-block, although of course the PHP language is capable of far more than simply repeating something you tell it. Nevertheless, even this little mini-block should come in handy to those who would otherwise run screaming if they saw its contents. By saving it to our [tt]sources_custom/miniblocks[/tt] directory it is already available to our users, who just need to write
[code][block]main_openstreetmap[/block]
[/code]
 (or whatever else you called it, without the ".php" at the end). I've attached a screenshot of this mini-block embedded on the homepage of a test installation of Composr 5.0.3.
[attachment_safe thumb="0" type="island" description=""]5408[/attachment_safe]
In further tutorials we can explore how to make more powerful blocks, for example blocks which we can give whichever longitude, latitude and zoom we want.

If you wish to turn your mini-block into a Composr addon that anyone can install then you can follow the instructions and diagrams in this section of the [url="http://compo.sr/docs/tut_framework.htm#title__9"]Composr programming framework tutorial[/url]. Composr, by default, gives administrators access to a "tree view" of all the addons which have been published on compo.sr. This means that, if you upload your addon to compo.sr, it will appear inside (almost) every Composr installation in the world, and can be downloaded and installed automatically with just a few clicks!


I have recently suffered several 'Hack Attacks' and viewed many 'Stack Traces'. This triggered something in my dim grey cells, so I dug out the minilblock tute by [b]ChrisW[/b], and went to work.

It only took a few minutes, honest! And the satisfaction from following a well written tute and delivering something I would never have attempted in the past, is beyond measure.

Thanks ChrisW!

[attachment_safe thumb="1" type="island" description=""]5686[/attachment_safe]

-------------------------------------------------

The code:
[codebox="php"]
<?php 
/* This is an attempt to build a miniblock. The content, a game, is another twist on the well-known Tetris original. Warning: it is addictive. Enjoy! */
echo '<div align="center"><h1>Stack Attack - A Logic Game</h1><br /><object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0" width="480" height="320" id="6724004770.swf" align="center"><param name="movie" value="http://www.freegaming.de/components/flash/6724004770.swf" /><param name="quality" value="high" /><param name="bgcolor" value="#e8ffff" /><param name="menu" value="false" /><param name="borderStyle" value ="1" /><comment><embed src="http://www.freegaming.de/components/flash/6724004770.swf?affiliate_id=941efa0f97e566c4" quality="high" bgcolor="#e8ffff" width="450" height="320" style="border:1px solid #869aa7; padding:2px;" name="6724004770.swf" menu="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer"></embed><noembed></noembed></comment></object><br /><br /><a style="font-size:9px;" href="http://www.freegaming.de" target="_blank">More Games</a></div>';
[/codebox]

Enjoy!

 :P 

[b]P.S.[/b] Completely forgot - put it down to senility!
 - Name the mini-block whatever you want. I called mine [tt]stack-attack.php[/tt] (what else?)
 - Save the mini-block in your [tt]sources_custom/miniblocks/[/tt] folder
 - To use it I simply wrapped [tt]stack-attack[/tt] with '[b]block[/b]' comcode tags
 - The result is as you see it

 :thumbs: 

[title="2"]More Useful mini-blocks Via Functions[/title]
 
In the previous section, we saw how to write the PHP necessary for Composr to run our commands. In this short tutorial we will expand on this to create more interesting and useful mini-blocks, which do more than simply repeat what they're told.

[title="3"]Functions[/title]

One of the most widely used ideas in programming is that of the [i]function[/i]. Like functions in Maths (such as [url="http://en.wikipedia.org/wiki/Sine"]sine[/url] and [url="http://en.wikipedia.org/wiki/Cosine"]cosine[/url]), functions can be used in PHP to re-use some process which has been defined before. All that is required to use a function is knowing its name, knowing what it needs to be given to act upon (eg. sine and cosine need to be given an angle to work with) and having it available to your program (not every function is available all of the time, since it would take up far too much memory to have them all waiting around and not being used). What makes functions so powerful is that in order to use them, we don't need to care about how they do what they do (their "implementation"), all we have to know is how to make them run ("calling" them).

Using a function in PHP is the same as in Maths, where we just write the function's name, then put whatever we want it to act upon (its "arguments") inside some parentheses (brackets) next to the name. For instance "sine(2)". If we need to give a function multiple arguments then we put commas between them, for example if we wanted the maximum of a series of numbers we might say "max(6,3,98.5,12)". If a function doesn't require any arguments then we simply leave the brackets empty, for example if we want a random number we might write "random()". The difference between functions in Maths and functions in programming is that programming functions don't just turn numbers into other numbers, they can do anything that the language (in our case PHP) is capable of. Here are some examples of using PHP functions (with comments describing what they do):

[php]
// 2 whole number arguments. Gives us an image
// with a palette of 16,777,216 colours, a width of
// 800 pixels and a height of 600 pixels.
imagecreatetruecolor(800,600)

// 1 text ("string") argument. Gives us the
// lowercase text 'hello world'.
strtolower('HELLO WORLD')

// No arguments. Gives us the "base URL"
// option of a Composr site
get_base_url()
[/php]

Since a function can "give back" some value (we say it "returns" the value) we can pass this straight into another function as an argument by simply nesting the calls to the functions, like this:

[php]
// This will call the "get_base_url" function,
// which gives us a text string, and passes
// that string straight to the "strtoupper"
// function which makes it uppercase.
strtoupper(get_base_url())
[/php]

We will use the variety of functions defined by PHP and Composr to spice up our map mini-block.

[title="3"]Using Functions In mini-blocks[/title]

Composr defines many functions, and a comprehensive description of them all can be found in the [url="http://compo.sr/docs/api/"]Application Programmers' Interface documentation[/url]. Here we will use a few simple functions to make the output of our map mini-block more useful. The functions we'll use are:
 - array, which takes any number of arguments of any type. It gives back an "array", or ordered list, containing whatever arguments you gave it. For example "array('a','b','c','d',9,10,11,12)" will return an array (list) of values ('a','b','c','d',9,10,11,12).
 - implode, which takes as arguments a string of text and an array of text strings. It returns a text string generated by sticking together each string in the array argument, with the string argument in between. For example "implode('hello',array('a','b','cde','f'))" will return a string of text 'ahellobhellocdehellof'.
 - strval, which takes an argument of any type and returns a text string representing it. For example "strval(58.7)" will return the text string '58.7' (which is not the same as the number 58.7, since that isn't a text string, it's a number).
 - get_option, which takes a string argument which should be the name of a Composr configuration option. It returns the value of that option. For example "get_option('site_closed')" returns (in my case, with an open site) 0.

[title="3"]The Minimodule Code[/title]

The following is the code of our improved minimodule. We put it in a file in the same way as in the first example. I've decided to call this file "main_openstreetmap_options.php" so that I can have both versions of the minimodule installed at once. The code still produces the HTML we took from openstreetmap.org like before, but rather than putting the whole thing in quotes and using it as-is, we split it up so that optional bits, like the values for width and height, can be swapped out for the values of Composr configuration options.
We then use the "echo" command to output each of these bits in turn, so that the browser sees them as one long piece of HTML. A few points to notice are that we keep the quote marks and commas of the HTML intact, which is important since the browser will be expecting them; we also put our calls to the "get_option function inside a call to the "strval" function, this is because our options will give us numbers and we want to convert them into text string (which strval does for us); finally we add 0.01 to the longitude and latitude at one point, this is because the OpenStreetMap code uses a different value for the left, right, top and bottom of the map so we need to keep them slightly apart or else our map will have zero contents.

[php]
<?php
/* This is a minimodule to show a map from OpenStreetMap.org.
It uses site configuration options to determine what should be
displayed */
echo '<iframe width="';  // HTML
echo strval(get_option('map_width'));
echo '" height="';  // HTML
echo strval(get_option('map_height'));
echo '" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="http://www.openstreetmap.org/export/embed.html?bbox=';  // HT$
echo strval(get_option('longitude'));
echo ',';  // HTML
echo strval(get_option('latitude'));
echo ',';  // HTML
echo strval(get_option('longitude')+0.01);  // Give the map an area of 0.01x0.01
echo ',';  // HTML
echo strval(get_option('latitude')+0.01);  // Give the map an area of 0.01x0.01
echo '&amp;layer=mapnik" style="border: 1px solid black"></iframe><br/><small><a href="http://www.openstreetmap.org/?lat=';  // HTML
echo strval(get_option('latitude'));
echo '&amp;lon=';  // HTML
echo strval(get_option('longitude'));
echo '&amp;zoom=';  // HTML
echo strval(get_option('map_zoom'));
echo '&amp;layers=M">View Larger Map</a></small>';  // HTML
[/php]

This is starting to look complicated isn't it! We just need to keep in mind that everything inside /* and */ are just comments, they're not part of the code, as are the comments after the slashes "//". Everything that is just repeating the copy-pasted HTML from before has been given the comment "HTML". Disregarding those bits we see that the only new parts are the function calls and the "+0.01".

Notice that each line ends in a semicolon ";" like the "echo" line in our first example. It's very common to forget to put these, so it may help if you think of semicolons as the symbol for "and then". For example
[php]1 + 2;
3 + 4;
[/php]
Means "one plus two and then three plus four and then (end)". If you're having problems with your mini-block then I'd recommend you check each line for its semicolon, and check whether your opening and closing quotes match.

[title="3"]Required Composr Setup[/title]

This mini-block uses functions to get Composr options, however I've made up these options for the example. In order for this mini-block to work we need to add these options to the Composr site we're going to run it on (you probably won't want to do this on a live site if you're only experimenting. I do my experimenting on a local installation of Composr that I don't mind reinstalling whenever I mess it up ;) ). The following code will do it:

[php]
<?php
add_config_option('MAP_WIDTH','map_width','integer','return 300;','BLOCKS','MAP_BLOCK');
add_config_option('MAP_HEIGHT','map_height','integer','return 300;','BLOCKS','MAP_BLOCK');
add_config_option('MAP_ZOOM','map_zoom','integer','return 16;','BLOCKS','MAP_BLOCK');
add_config_option('LONGITUDE','longitude','float','return 0.0;','BLOCKS','MAP_BLOCK');
add_config_option('LATITUDE','latitude','float','return 0.0;','BLOCKS','MAP_BLOCK');
[/php]

As you can see, it's all just more function calls with text string arguments. In order to run this code, you can either use the "Commandr" commandline from your site's admin zone (put a colon in the entry box and copy in the first "add_config_option" line then press the "Go" button, then repeat for the rest of the "add_config_option" lines) or you can save them to a file called "set_up_map.php" inside the "minimodules_custom" folder of the "pages" folder in the "adminzone" folder of your installation. Now you can run it by visiting your site with "/adminzone/index.php?page=set_up_map" at the end of the address. You've just made your first "minimodule", which you can learn about in other tutorials :)

The next thing to do is to set up the translation strings needed by these options. In Composr prettty much everything is translatable, so we can't just give an English name to the add_config_option function and leave all non-English speakers unable to use the mini-block. Instead, what we gave to the add_config_option function were code names which we can use to reference these options' names. Now we must define these names in at least one language.

The quickest way to do this is to put them in the "global" language file, which is available to all parts of the site. We're going to define the names for English, so copy the file "lang/EN/global.ini" in your Composr installation into the folder "lang_custom/EN" then open this copy in your programming text editor. Go to the end of the file and add these lines:

[code]
MAP_BLOCK=Map block
MAP_WIDTH=Map width
MAP_HEIGHT=Map height
MAP_ZOOM=Zoom level
LONGITUDE=Longitude
LATITUDE=Latitude
CONFIG_GROUP_DESCRIP_MAP_BLOCK=Parameters to control the OpenStreetMap block.
[/code]

Save the file and visit your site's admin zone. Go to "Configuration" under the "Setup" menu and click on "Block options". There should be a section called "Map block" where you can enter the latitude, longitude, width, height and zoom level of the map.

[title="3"]Using the mini-block[/title]

To include this new mini-block on a page you just need to call it from Comcode like any other block or mini-block via the code [no_parse][block]main_openstreetmap_options[/block][/no_parse] (or whatever filename ou gave it, without the ".php"). Below is a screenshot of this mini-block embedded on the homepage of a test site.
[attachment_safe thumb="1" type="island" description=""]5410[/attachment_safe]

I hope you've not been too overwhelmed by this further exploration of Composr, PHP and programming in general :)

If you wish to turn your mini-block into a Composr addon that anyone can install then you can follow the instructions and diagrams in this section of the [url="http://compo.sr/docs/tut_framework.htm#title__9"]Composr programming framework tutorial[/url]. Composr, by default, gives administrators access to a "tree view" of all the addons which have been published on compo.sr. This means that, if you upload your addon to compo.sr, it will appear inside (almost) every Composr installation in the world, and can be downloaded and installed automatically with just a few clicks!

[title="2"]Controlling Data In mini-blocks Via Variables[/title]

In this short tutorial we'll learn a little more about the PHP programming language and the various techniques it offers to us when we're writing code. In the last section, we learned how to use [i]functions[/i]. These are a fundamental part of Composr programming, but there are a few more PHP features which we'll need to use as we dig further and further into Composr. To keep things as comfortable as possible we'll be learning them one at a time from the comfort of our familiar miniblocks.

In the previous tutorial we learned how to do interesting things by "calling" (running) functions. This time we'll take a look at [i]variables[/i] and [i]state[/i].

[title="3"]Introduction[/title]

We saw that functions can give us values to work with, such as the value of a Composr configuration option. We also saw that we can [i]nest[/i] function calls; that is, use the value given by a function call as an argument for another function call, such as:

[php]
strtoupper(get_base_url());  // Get the site's base URL and make it uppercase
[/php]

We can nest as many such calls as we like, for example:

[php]
strlen(strval(strlen(get_base_url())))
[/php]

This will give the number of digits in the length of a Composr site's "base URL" option. Remember that the arguments of a function are worked out first, then the function is called with those values. This means that "get_base_url()" will be worked out first, which gives a text string (from now on we'll refer to text as just "strings"), and this is given straight to the "strlen" function which gives us the number of letters and other characters in a string. This number is then sent to the "strval" function, which converts the number into a string of the number (ie. a number like 12 will become the string "12"). We then send this straight to the "strlen" function which, again, counts how many characters are in the string. Since the string is just that of a positive whole number, this will be the number of digits.

[title="3"]Variables[/title]

Using functions in the way shown above can get very confusing. Luckily there is a way to cut down on this confusion, once again borrowing an idea from Maths; the [i]variable[/i].

Rather than using variables to represent unknown values like in Maths (eg. "Solve for x") instead we can use variables to 'store' values temporarily, so that we can refer to them later. This is very useful if the result you want to work out depends on performing lots of steps, like the heavily nested function calls above. In PHP, variables are written as a name with a dollar sign, "$", at the beginning, for example [php]$my_variable[/php]. Don't ask me why they force everyone to write dollar signs, PHP is full of silly rules.

We can 'store' a value in a variable by saying that the variable is equal to the value (we call this "assigning" the variable), like this:

[php]
$url = get_base_url();
[/php]

Now we can use the short name "$url" instead of the longer function call "get_base_url()" (its also more efficient, since the value only has to be worked out once). Notice the semicolon at the end, which means that this is an instruction to carry out (a "statement"). Assignment statements can do one of two things:
 - Define a new variable (if the variable written on the left hasn't been used yet)
 - Change the value stored in an existing variable (if the variable has been used before)

It is important to understand what PHP does when it sees an assignment statement, which is this:
 1) Work out the value of what is on the right hand side.
 2) Store this in the variable on the left hand side.

This means that the left hand side must be a variable name and nothing else and the right hand side must work out to the value we want and nothing else. This is different to the symmetric equalities found in Maths, where we can swap what's on each side around and it makes no difference, and also it means we can't get PHP to work out things like "$x + 20 = 25;", since "$x + 20" isn't a variable name (we can usually avoid such situations by using very simple algebra to rearrange the equation such that only the variable name is on the left).

Another very important difference between PHP and Maths is that in Maths we make statements which are 'timeless', ie. they are statements of truth which don't depend on how we say them. For example we could say "x = y" and "y = 5"; this, of course, means that "x = 5". In PHP however, everything is worked out in a sequence. If we try writing this example in PHP:
[php]
$x = $y;
$y = 5;
[/php]
This will give an error, because when PHP reaches the first assignment instruction, it will complain that it doesn't know what $y is (since it's not reached the instruction which defines it yet). This leads to the idea of a program's [i]state[/i].

[title="3"]State[/title]

PHP will start at the top of whichever file it is given (eg. when a PHP file is accessed by a browser) and carry out each instruction it is given until it either reaches the end of the file or one of the instructions is to exit. On the way, it can go through other instructions if told to; for example a function call like "get_base_url()" is actually an instruction to go the definition of "get_base_url" (which lives deep within Composr's guts), run through those instructions, then come back when it's finished. The consequence is that PHP, unlike a person doing some Maths, is not smart enough to go looking through the code until it finds the definition of things; all it does is remember what it's been told previously.

The currently defined variables (and functions) along with their values makes up what is called the program's [i]state[/i] (or 'memory'). As we saw, assignment can change the program's state by defining a new variable or changing the value stored in a variable. This second possibility is the one that causes the most confusion, since it seems to defy the laws of Maths. Consider the following, which all makes perfect sense if you understand the way PHP uses state:

[php]
$my_age = 22;
// Simple enough, $my_age now stores 22

$my_age_string = strval($my_age);
// $my_age_string now stores the string "22"

$my_age = $my_age + 1;
// The above line makes no sense if we think in terms of regular
// Maths, but it does make sense in PHP.
// First the right hand side will be worked out to give the value
// 23, then this will be assigned to $my_age, so that $my_age now
// stores the value 23. This line has changed the program's state

$my_new_age_string = strval($my_age);
// $my_new_age_string stores the string "23", but $my_age_string
// still stores "22" since it was defined before the state
// changed. Thus we've used the same code, "strval($my_age)",
// and received different results, because it depends on the
// state of the program; specifically, the state of $my_age.
[/php]

Since we can change the value of our variables at any time, we have to be careful about any assumptions we make about these values. For example, just because you see "$my_variable = 12;" in some part of the code, this doesn't mean that you can write some new code somewhere else that uses $my_variable and assume it is 12, since the state may have changed in-between, or your code might run before that definition is made (in fact PHP has a feature called [i]scope[/i] which will stop you making such assumptions, which will be explained in a later tutorial).

Don't worry if you find the idea of state difficult to grasp at first; although it is very powerful, stateful programming can be fraught with bugs and is very hard to model and describe Mathematically (ie. it's very hard to prove whether state is being used correctly).

Personally, I favour defining new variables for things as I go (a loose form of the 'single assignment' programming style), rather than using a few variables and constantly changing the values they store. Although re-using variables makes more efficient use of memory (we overwrite any old values we don't need any more, rather than remembering them) it can cause easily avoidable headaches. For example, consider this piece of code:
[php]
// Get the site's base URL
$address = get_base_url();

// Send the user a HTML "anchor" which links to the site's base URL
echo '<a href="';
echo htmlentities($address);  // htmlentities turns strings into a form that won't interfere with HTML
echo '">Homepage</a>';

// Take some parameters from a submitted form
$name = post_param_string('name');
$age = post_param_integer('age');
$address = post_param_string('address');

// Send a message to the user
echo '<p>Hello ';
echo $name;
echo ' of ';
echo $address;
echo ', I see that you are ';
echo strval($age);
echo ' years old.';
echo '</p>';

// Give the user another homepage link
echo '<a href="';
echo htmlentities($address);
echo '">Go back to the homepage</a>';
[/php]

Here we've used the variable $address for storing both the Web site's address and the user's home address. This has caused a bug since the "Go back to the homepage" link won't work, as it's trying to link to the user's home address! This bug isn't completely obvious, and PHP certainly won't spot it. We can fix it by either repeating the line [php]$address = get_base_url();[/php] between showing the message and showing the second link; or we can use a different name, like $user_address, for the user's home address. I'd prefer to do the latter, since then we don't have to worry about what's happened to $address; we can reuse $address anywhere we like without having to worry about what's stored inside it, since we never change it.

[title="3"]A mini-block Example[/title]

Now that we've learned about variables, let's see how we can use them to make a seemingly complicated mini-block much simpler. Here we find out how many site points the current user has spent and has available to spend ("points" are a Composr feature where users get rewarded for contributing to the site), we store these in variables then we use echo to send the user a HTML image. The image uses [url="http://code.google.com/apis/chart"]Google Chart API[/url] to automatically generate a pie chart showing these values. Here's the code:

[php]
<?php
/* This will use Google Chart API to draw a graph of the current
   user's points availability. */

// First we get the current user ID
$userid = get_member();

// Now we get information about their points usage

// Load sources/points.php where the functions are defined
require_code('points');

// Call the functions and store their values in some variables
$available = available_points($userid);
$used = points_used($userid);

// Now we create a pie chart of these results. The way we do this
// is to send the user a HTML image with the URL containing the
// data, such that Google can turn it into a pie chart.
// The details of how these URLs work can be found at
// http://code.google.com/apis/chart
// A HTML image is written as <img src="url" alt="text" /> where
// url is the image's URL and text is a text alternative for
// those who browse in a text-only way.

// We start the image declaration
echo '<img src="';

// Then we set the start of the URL to Google's chart API
echo 'https://chart.googleapis.com/chart?';

// Now we put all of our options at the end of the URL
echo 'cht=p3';  // We want a 3D pie chart
echo '&chtt=Your Points';  // The chart title
echo '&chco=0000FF';  // Make the chart blue
echo '&chs=300x150';  // Make it 300 pixels wide and 150 pixels tall
echo '&chd=t:';  // Start declaring the data
echo strval($used);  // The amount of points used
echo ',';  // Separator
echo strval($available);  // The amount of unused points
echo '&chds=0,';  // The smallest data value
echo strval($available);  // The largest data value
echo '&chl=Used|Available';  // Give labels to the data

// Now we give a text alternative and finish the declaration
echo '" alt="Your Points: ';
echo strval($used);
echo ' used, ';
echo strval($available);
echo ' available." />';
[/php]

The parameters we add to the end of the image URL may seem incomprehensible, but they are described with plenty of examples on [url="http://code.google.com/apis/chart"]Google's site[/url]. I hope you have fun playing with variables, state and Google's chart generator. I've saved this to my Composr test installation as sources_custom/miniblocks/main_userpoints.php and here is a screenshot of the mini-block used in a news article, via the comcode [no_parse][block]main_userpoints[/block][/no_parse] (after I'd gambled away some points in the points store ;) ). Every user who views the article will see a chart of their own points.
[attachment_safe thumb="1" type="island" description=""]5433[/attachment_safe]

If you wish to turn your mini-block into a Composr addon that anyone can install then you can follow the instructions and diagrams in this section of the [url="http://compo.sr/docs/tut_framework.htm#title__9"]Composr programming framework tutorial[/url]. Composr, by default, gives administrators access to a "tree view" of all the addons which have been published on compo.sr. This means that, if you upload your addon to compo.sr, it will appear inside (almost) every Composr installation in the world, and can be downloaded and installed automatically with just a few clicks!

{$SET,tutorial_tags,Development,PHP,expert}{$SET,tutorial_add_date,Aug 12}{$SET,tutorial_summary,A worked guide to writing new blocks for Composr.}[block]main_tutorial_rating[/block]
