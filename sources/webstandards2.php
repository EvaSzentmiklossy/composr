<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2016

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core_webstandards
 */

/*EXTRA FUNCTIONS: pspell\_.+*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__webstandards2()
{
    $enforce_javascript = '([^\n]+)';
    $enforce_lang = '[a-zA-Z][a-zA-Z](-[a-zA-Z]+)?';
    $enforce_direction = '(ltr|rtl)';
    $enforce_align = '(left|center|right|justify|char)';
    $enforce_align2 = '(top|middle|bottom|left|right)';
    $enforce_align3 = '(left|center|right|justify)';
    $enforce_align4 = '(top|bottom|left|right)';
    $enforce_valign = '(top|middle|bottom|baseline)';
    $enforce_number = '(-?[0-9]+)';
    $enforce_inumber = '[0-9]+';
    $enforce_character = '.';
    $enforce_color = '(black|silver|gray|white|maroon|purple|fuchsia|green|lime|olive|yellow|navy|blue|teal|aqua|orange|red|(\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])|(\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]))'; // orange and red aren't 'official' -- but kind of handy ;). In reality, the colour codes were never properly defined, and these two are obvious names for obviously needed ones-- they'll be supported
    $enforce_length = '((0)|(' . $enforce_number . '(|in|cm|mm|ex|pt|pc|px|em|%))|((' . $enforce_number . ')?\.' . $enforce_number . '(in|cm|mm|ex|em|vh|vw|vmin|rem|%)))'; // |ex|pt|in|cm|mm|pc  We don't want these in our XHTML... preferably we only want em when it comes to font size!
    $enforce_ilength = '((0)|(' . $enforce_inumber . '(|in|cm|mm|ex|pt|pc|px|em|%))|((' . $enforce_inumber . ')?\.' . $enforce_inumber . '(in|cm|mm|ex|em|vh|vw|vmin|rem|%)))'; // |ex|pt|in|cm|mm|pc We don't want these in our XHTML... preferably we only want em when it comes to font size!
    $enforce_pixels = '[0-9]+';
    $enforce_auto_or_length = '(auto|' . $enforce_length . ')';
    $enforce_auto_or_ilength = '(auto|' . $enforce_ilength . ')';
    $enforce_normal_or_length = '(normal|' . $enforce_length . ')';
    $enforce_border_width = '(thin|medium|thick|' . $enforce_length . ')';
    $enforce_potential_4d_border_width = $enforce_border_width . '( ' . $enforce_border_width . '( ' . $enforce_border_width . '( ' . $enforce_border_width . '|)|)|)';
    $enforce_css_color = '((rgb\(' . $enforce_inumber . '%,' . $enforce_inumber . '%,' . $enforce_inumber . '%\))|(rgb\(' . $enforce_inumber . ',' . $enforce_inumber . ',' . $enforce_inumber . '\))|(rgba\(' . $enforce_inumber . '%,' . $enforce_inumber . '%,' . $enforce_inumber . '%,' . $enforce_inumber . '%\))|(rgba\(' . $enforce_inumber . ',' . $enforce_inumber . ',' . $enforce_inumber . ',' . $enforce_inumber . '\.\d+\))|(\#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])|' . $enforce_color . '|ActiveBorder|ActiveCaption|AppWorkspace|Background|Buttonface|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)';
    $enforce_transparent_or_color = '(transparent|' . $enforce_css_color . ')';
    $enforce_fraction = '(\d%|\d\d%|100%|0\.\d+|1\.0|0|1)';
    $_enforce_font_list = "(cursive|fantasy|monospace|serif|sans-serif|Georgia|Times|Trebuchet|Tahoma|Geneva|Verdana|Arial|Helvetica|Courier|Courier New|Impact|'Georgia'|'Times'|'Trebuchet'|'Tahoma'|'Geneva'|'Verdana'|'Arial'|'Helvetica'|'Courier'|'Courier New'|'Impact')";
    $enforce_font_list = '((([A-Za-z]+)|("[A-Za-z ]+")|(\'[A-Za-z ]+\')),\s*)*' . $_enforce_font_list;
    $enforce_functional_url = '(url\(\'.+\'\)|url\(".+"\)|url\([^\(\);]+\))';
    $enforce_functional_url_or_none = '(' . $enforce_functional_url . '|none)';
    $enforce_border_style = '(none|dotted|dashed|solid|double|groove|ridge|inset|outset|transparent)';
    $enforce_background_repeat = '(repeat|repeat-x|repeat-y|no-repeat)';
    $enforce_attachment = '(scroll|fixed)';
    $_enforce_background_position = '((' . $enforce_length . '|top( ' . $enforce_length . ')?|center|bottom( ' . $enforce_length . ')?)|(' . $enforce_length . '|left( ' . $enforce_length . ')?|center|right( ' . $enforce_length . ')?))';
    $enforce_background_position = '((' . $_enforce_background_position . ')|(' . $_enforce_background_position . ' ' . $_enforce_background_position . '))';
    $enforce_border = '((' . $enforce_border_width . '|' . $enforce_border_style . '|' . $enforce_css_color . ')( |$))+';
    $enforce_potential_4d_length = $enforce_length . '( ' . $enforce_length . '( ' . $enforce_length . '( ' . $enforce_length . '|)|)|)';
    $enforce_potential_4d_length_auto = $enforce_auto_or_length . '( ' . $enforce_auto_or_length . '( ' . $enforce_auto_or_length . '( ' . $enforce_auto_or_length . '|)|)|)';
    $enforce_potential_4d_ilength = $enforce_ilength . '( ' . $enforce_ilength . '( ' . $enforce_ilength . '( ' . $enforce_ilength . '|)|)|)';
    $enforce_potential_4d_ilength_auto = $enforce_auto_or_ilength . '( ' . $enforce_auto_or_ilength . '( ' . $enforce_auto_or_ilength . '( ' . $enforce_auto_or_ilength . '|)|)|)';
    $enforce_font_style = '(normal|italic|oblique)';
    $enforce_font_variant = '(normal|small-caps)';
    $enforce_font_weight = '(lighter|normal|bold|bolder|((\d)+))';
    $enforce_list_style_position = '(inside|outside)';
    $enforce_list_style_type = '(none|disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|decimal-leading-zero|lower-greek|lower-latin|upper-latin|hebrew|armenian|georgian|cjk-ideographic|hiragana|katakana|hiragana-iroha|katakana-iroha)';
    $enforce_list_style_image = '(none|' . $enforce_functional_url . ')';
    $enforce_id = '[a-zA-Z][\w\-\:\.]*';
    $enforce_name = '[\w\-\:\.]+(\[\])?';
    if (function_exists('get_forum_type')) {
        require_code('obfuscate');
        $enforce_link = ((get_forum_type() == 'none') ? '(mailto:.*)?' : '') . '(mailto:.*|' . preg_quote(mailto_obfuscated(), '#') . '.*)?[^\s\#]*(\#[^\s\#]*)?';
    } else {
        $enforce_link = '.*';
    }
    $enforce_class = '[ \w-]*';
    $_counter_increment = '((\w+( \d+)?)+)';
    $enforce_counter_increment = $_counter_increment . '( ' . $_counter_increment . ')*';
    $enforce_transition_timing_function = '(linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier\(' . $enforce_fraction . ' ' . $enforce_fraction . ' ' . $enforce_fraction . ' ' . $enforce_fraction . '\))';
    $enforce_time = '\d[\d\.]*s';
    $enforce_box_shadow = '((inset )?' . $enforce_length . '( ' . $enforce_length . '( ' . $enforce_length . '( ' . $enforce_length . ')?)?)? ' . $enforce_css_color . ')';
    $enforce_transition_property = '[\w,\-]+';
    $enforce_transform_origin = '(left|center|right|' . $enforce_length . ')';
    $enforce_transform_style = '(flat|preserve-3d)';

    global $CSS_PROPERTIES;
    $CSS_PROPERTIES = array(
        'animation' => '.*',
        'animation-delay' => '.*',
        'animation-direction' => '.*',
        'animation-duration' => '\d+s',
        'animation-fill-mode' => '.*',
        'animation-iteration-count' => '.*',
        'animation-name' => '\w+',
        'animation-play-state' => '.*',
        'animation-timing-function' => '(linear|ease|ease-in|ease-out|ease-in-out|step-start|step-end|steps\(\d+(,(start|end))?\)|cubic-bezier\([\d\.]+,[\d\.]+,[\d\.]+,[\d\.]+\))',
        'backface-visibility' => '(hidden|visible)',
        'background' => '((' . $enforce_transparent_or_color . '|' . $enforce_functional_url_or_none . '|' . $enforce_background_repeat . '|' . $enforce_attachment . '|' . $enforce_background_position . ')( |$))+',
        'background-attachment' => $enforce_attachment,
        'background-clip' => '(border-box|padding-box|content-box)',
        'background-color' => $enforce_transparent_or_color,
        'background-image' => /*$enforce_functional_url_or_none*/'.*', // Changed to .* to allow gradients
        'background-origin' => '(border-box|content-box)',
        'background-position' => $enforce_background_position,
        'background-repeat' => $enforce_background_repeat,
        'background-size' => '(' . $enforce_length . ' ' . $enforce_length . ')',
        'border' => $enforce_border,
        'border-bottom' => $enforce_border,
        'border-bottom-color' => $enforce_transparent_or_color,
        'border-bottom-left-radius' => $enforce_length,
        'border-bottom-right-radius' => $enforce_length,
        'border-bottom-style' => $enforce_border_style,
        'border-bottom-width' => $enforce_border_width,
        'border-collapse' => '(collapse|separate)',
        'border-color' => $enforce_transparent_or_color . '( ' . $enforce_transparent_or_color . '( ' . $enforce_transparent_or_color . '( ' . $enforce_transparent_or_color . '|)|)|)',
        'border-image' => '.*',
        'border-image-outset' => $enforce_length,
        'border-image-repeat' => '(stretch|repeat|round|space)',
        'border-image-slice' => $enforce_length,
        'border-image-source' => /*$enforce_functional_url_or_none*/'.*', // Changed to .* to allow gradients
        'border-image-width' => $enforce_length,
        'border-left' => $enforce_border,
        'border-left-color' => $enforce_transparent_or_color,
        'border-left-style' => $enforce_border_style,
        'border-left-width' => $enforce_border_width,
        'border-radius' => $enforce_length . '( ' . $enforce_length . '( ' . $enforce_length . '( ' . $enforce_length . ')?)?)?',
        'border-right' => $enforce_border,
        'border-right-color' => $enforce_transparent_or_color,
        'border-right-style' => $enforce_border_style,
        'border-right-width' => $enforce_border_width,
        'border-spacing' => $enforce_length . '( ' . $enforce_length . ')?',
        'border-style' => $enforce_border_style,
        'border-top' => $enforce_border,
        'border-top-color' => $enforce_transparent_or_color,
        'border-top-left-radius' => $enforce_length,
        'border-top-right-radius' => $enforce_length,
        'border-top-style' => $enforce_border_style,
        'border-top-width' => $enforce_border_width,
        'border-width' => $enforce_potential_4d_border_width,
        'bottom' => $enforce_auto_or_length,
        'box-shadow' => '(none|(' . $enforce_box_shadow . '(,\s*' . $enforce_box_shadow . '(,\s*' . $enforce_box_shadow . '(,\s*' . $enforce_box_shadow . ')?)?)?))',
        'box-sizing' => '(border-box|content-box|padding-box)',
        'caption-side' => 'top|bottom|left|right',
        'clear' => '(both|left|right|none)',
        'clip' => 'auto|(rect\(' . $enforce_potential_4d_length . '\))',
        'color' => $enforce_css_color,
        'content' => '.+',
        'counter-increment' => $enforce_counter_increment,
        'counter-reset' => $enforce_counter_increment,
        'cursor' => '(' . $enforce_functional_url . '|default|auto|n-resize|ne-resize|e-resize|se-resize|s-resize|sw-resize|w-resize|nw-resize|crosshair|pointer|move|text|wait|help|progress)',
        'direction' => '(ltr|rtl)',
        'display' => '(none|inline|block|list-item|table|table-header-group|table-footer-group|inline-block|run-in|inline-table|table-row|table-row-group|table-column-group|table-column|table-cell|table-caption|flex|-ms-flexbox|-\w+-flex)',
        'empty-cells' => 'show|hide',
        'float' => '(left|right|none)',
        'font' => '((caption|icon|menu|message-box|small-caption|status-bar|' . $enforce_font_style . '|' . $enforce_font_variant . '|' . $enforce_font_weight . '|' . $enforce_length . '|' . $enforce_normal_or_length . '|' . $enforce_font_list . ')( |$))+',
        'font-family' => $enforce_font_list,
        'font-size' => 'larger|smaller|xx-small|x-small|small|medium|large|x-large|xx-large|' . $enforce_length,
        'font-style' => $enforce_font_style,
        'font-variant' => $enforce_font_variant,
        'font-weight' => $enforce_font_weight,
        'height' => $enforce_auto_or_length,
        'left' => $enforce_auto_or_length,
        'letter-spacing' => $enforce_normal_or_length,
        'line-height' => $enforce_normal_or_length,
        'list-style' => '((' . $enforce_list_style_type . '|' . $enforce_list_style_position . '|' . $enforce_list_style_image . ')( |$))+',
        'list-style-image' => '(' . $enforce_functional_url . '|none)',
        'list-style-position' => $enforce_list_style_position,
        'list-style-type' => $enforce_list_style_type,
        'margin' => $enforce_potential_4d_length_auto,
        'margin-bottom' => $enforce_auto_or_length,
        'margin-left' => $enforce_auto_or_length,
        'margin-right' => $enforce_auto_or_length,
        'margin-top' => $enforce_auto_or_length,
        'marker-offset' => $enforce_auto_or_length,
        'max-height' => $enforce_auto_or_length,
        'max-width' => $enforce_auto_or_length,
        'min-height' => $enforce_auto_or_length,
        'min-width' => $enforce_auto_or_length,
        'opacity' => $enforce_fraction,
        'outline' => $enforce_border,
        'outline-color' => $enforce_transparent_or_color,
        'outline-style' => $enforce_border_style,
        'outline-width' => $enforce_border_width,
        'overflow' => '(visible|hidden|scroll|auto)',
        'overflow-x' => '(visible|hidden|scroll|auto)',
        'overflow-y' => '(visible|hidden|scroll|auto)',
        'padding' => $enforce_potential_4d_ilength,
        'padding-bottom' => $enforce_auto_or_ilength,
        'padding-left' => $enforce_auto_or_ilength,
        'padding-right' => $enforce_auto_or_ilength,
        'padding-top' => $enforce_auto_or_ilength,
        'page-break-after' => '(auto|left|right|always)',
        'page-break-before' => '(auto|left|right|always)',
        'perspective' => $enforce_length,
        'perspective-origin' => $enforce_background_position,
        'position' => '(static|relative|absolute|fixed)',
        'quotes' => '.+ .+',
        'right' => $enforce_auto_or_length,
        'table-layout' => '(auto|fixed)',
        'text-align' => '(left|right|center|justify)',
        'text-decoration' => '(underline|line-through|none|blink)',
        'text-indent' => $enforce_length,
        'text-shadow' => '(none|(' . $enforce_length . ' ' . $enforce_length . '( ' . $enforce_length . ')?( ' . $enforce_css_color . ')?))',
        'text-transform' => '(capitalize|uppercase|lowercase|none)',
        'top' => $enforce_auto_or_length,
        'transform' => '(none|\w+\([^\(\)]+\))',
        'transform-origin' => $enforce_transform_origin . '( ' . $enforce_transform_origin . '( ' . $enforce_transform_origin . ')?)?',
        'transform-style' => $enforce_transform_style,
        'transition' => $enforce_transition_property . '( ' . $enforce_time . '( ' . $enforce_transition_timing_function . '( ' . $enforce_time . ')?)?)?',
        'transition-delay' => $enforce_time,
        'transition-duration' => $enforce_time,
        'transition-property' => $enforce_transition_property,
        'transition-timing-function' => $enforce_transition_timing_function,
        'unicode-bidi' => '(bidi-override|normal|embed)',
        'vertical-align' => '(baseline|sub|super|top|text-top|middle|bottom|text-bottom|' . $enforce_length . ')',
        'visibility' => '(hidden|visible|collapse)',
        'white-space' => '(normal|pre|nowrap|pre-wrap|pre-line)',
        'width' => $enforce_auto_or_length,
        'word-spacing' => $enforce_normal_or_length,
        'z-index' => '(auto|(\d+))',

        /* Purposely left out these CSS features due to very poor browser support or generally irrelevancy */
        /*
        (print module)
        (aural module)
        (columns module)
        (low level font and color settings)
        */

        /* These are non standard but we want them */
        'writing-mode' => '(tb-rl|lr-tb)', // A more complex W3C standard is underway. Only IE supports this one.
        'word-wrap' => '(normal|break-word)', // Was renamed to overflow-wrap, but that name is not supported widely
    );

    define('CSS_AT_RULE_BLOCK', -4);
    define('CSS_AT_RULE', -3);
    define('CSS_NO_MANS_LAND', -2);
    define('CSS_EXPECTING_IDENTIFIER', -1);
    define('CSS_IN_COMMENT', 0);
    define('CSS_IN_CLASS', 1);
    define('CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS', 2);
    define('CSS_IN_IDENTIFIER', 3);
    define('CSS_IN_PSEUDOCLASS_EXPRESSION', 6);

    define('_CSS_NO_MANS_LAND', 0);
    define('_CSS_IN_PROPERTY_KEY', 1);
    define('_CSS_IN_PROPERTY_BETWEEN', 2);
    define('_CSS_IN_PROPERTY_VALUE', 3);
    define('_CSS_IN_COMMENT', 4);
    define('_CSS_EXPECTING_END', 5);
}

/**
 * Checks an XHTML tag for conformance, including attributes. Return the results.
 *
 * @param  string $tag The name of the tag to check
 * @param  map $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @param  list $errors Errors detected so far. We will add to these and return
 * @return array Array of error information
 *
 * @ignore
 */
function __check_tag($tag, $attributes, $self_close, $close, $errors)
{
    global $XML_CONSTRAIN, $TAG_STACK, $ATT_STACK, $TABS_SEEN, $KEYS_SEEN, $IDS_SO_FAR, $ANCESTER_BLOCK, $ANCESTER_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $TAG_RANGES, $WEBSTANDARDS_CSP;

    // CSP violation
    if ($WEBSTANDARDS_CSP) {
        if ($tag == 'script') {
            $errors[] = array('CSP_SCRIPT_TAG');
        }

        foreach (array_keys($attributes) as $attribute) {
            if (substr($attribute, 0, 2) == 'on') {
                $errors[] = array('CSP_EVENT_HANDLER');
            }
        }
    }

    // Dodgy mouse events.
    if ((isset($attributes['onclick'])) && (strpos($attributes['onclick'], '/*Access-note: code has other activation*/') === false) && ((!isset($attributes['onmouseover'])) || (strpos($attributes['onmouseover'], 'activate_rich_semantic_tooltip') === false)) && (!isset($attributes['onkeypress'])) && (!isset($attributes['onkeydown'])) && (!isset($attributes['onkeyup'])) && (!in_array($tag, array('a', 'input', 'textarea', 'select', 'button')))) {
        $errors[] = array('WCAG_MOUSE_EVENT_UNMATCHED');
    }
    if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
        if ((isset($attributes['onmouseover'])) && (!isset($attributes['onfocus'])) && (in_array($tag, array('a', 'area', 'button', 'input', 'label', 'select', 'textarea')))) {
            $errors[] = array('WCAG_MOUSE_EVENT_UNMATCHED');
        }
        if ((isset($attributes['onmouseout'])) && (!isset($attributes['onblur'])) && (in_array($tag, array('a', 'area', 'button', 'input', 'label', 'select', 'textarea')))) {
            $errors[] = array('WCAG_MOUSE_EVENT_UNMATCHED');
        }
    }

    // Unexpected tags
    if (($EXPECTING_TAG !== null) && ($EXPECTING_TAG != $tag)) {
        $errors[] = array('XHTML_EXPECTING', $EXPECTING_TAG);
    }
    $EXPECTING_TAG = null;

    // Note that we do NOT take into account display:inline, because the W3C one doesn't either - probably because 'display' implies not 'semantic'
    $tmp = _check_blockyness($tag, $attributes, $self_close, $close);
    if ($tmp !== null) {
        $errors = array_merge($errors, $tmp);
    }

    if (array_key_exists('xmlns', $attributes)) {
        global $UNDER_XMLNS;
        $UNDER_XMLNS = true;
    }

    // Look for unknown attributes, or bad values
    $tmp = _check_attributes($tag, $attributes, $self_close, $close);
    if ($tmp !== null) {
        $errors = array_merge($errors, $tmp);
    }

    if (!$close) {
        if ($GLOBALS['MAIL_MODE']) {
            if (in_array($tag, array('style', 'object', 'applet', 'embed', 'form', 'map'))) {
                $errors[] = array('MAIL_BAD_TAG', $tag);
            }
            if ($tag == 'script') {
                $errors[] = array('MAIL_JAVASCRIPT');
            }
            foreach (array_keys($attributes) as $atr) {
                if (substr(strtolower($atr), 0, 2) == 'on') {
                    $errors[] = array('MAIL_JAVASCRIPT');
                }
            }
            if (($tag == 'body') && (count($attributes) != 0) && ($attributes != array('style' => 'margin: 0'))) {
                $errors[] = array('MAIL_BODY');
            }
        }

        // Check all required attributes are here
        global $TAG_ATTRIBUTES_REQUIRED;
        if ((isset($TAG_ATTRIBUTES_REQUIRED[$tag])) && (($tag != 'html') || ($XML_CONSTRAIN))) {
            $diff = array_diff($TAG_ATTRIBUTES_REQUIRED[$tag], array_keys($attributes));
            foreach ($diff as $attribute) {
                $errors[] = array('XHTML_MISSING_ATTRIBUTE', $tag, $attribute);
            }
        }

        // Iframes and CSS sheets need external checking
        if ($GLOBALS['WEBSTANDARDS_EXT_FILES']) {
            $tmp = _check_externals($tag, $attributes, $self_close, $close);
            if ($tmp !== null) {
                $errors = array_merge($errors, $tmp);
            }
        }

        // Check our links are OK
        if (($tag == 'a') && (isset($attributes['href']))) {
            if ((substr($attributes['href'], 0, 5) == 'mailto:') && (strpos($attributes['href'], '&') === false) && (strpos($attributes['href'], 'unsubscribe') !== false)) {
                $errors[] = array('XHTML_SPAM');
            }
            $tmp = _check_link_accessibility($tag, $attributes, $self_close, $close);
            if ($tmp !== null) {
                $errors = array_merge($errors, $tmp);
            }
        }

        // Embed is a special case
        //if (($tag == 'embed') && (!$self_close)) $EXPECTING_TAG = 'noembed'; // noembed not valid in (X)HTML5

        if (($tag == 'fieldset') && (!$self_close)) {
            $EXPECTING_TAG = 'legend';
        }
    } else {
        if ($tag == 'a') {
            $LAST_A_TAG = $TAG_RANGES[count($TAG_RANGES) - 1][1];
        }
    }

    // Check our form labelling is OK
    $tmp = _check_labelling($tag, $attributes, $self_close, $close);
    if ($tmp !== null) {
        $errors = array_merge($errors, $tmp);
    }

    if (!$close) { // Intentionally placed after labelling is checked
        if (($tag == 'input') || ($tag == 'select')) {
            if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (isset($attributes['name'])) && (stripos($GLOBALS['OUT'], 'privacy') === false)) {
                $privacy = array('dob', 'name', 'age', 'address', 'date_of_birth', 'dateofbirth', 'email', 'e_mail', 'gender', 'salutation');
                foreach ($privacy as $priv) {
                    if (stripos($attributes['name'], $priv) !== false) {
                        $errors[] = array('MANUAL_PRIVACY');
                    }
                }
            }
        }

        switch ($tag) {
            case 'meta':
                if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (isset($attributes['name'])) && ($attributes['name'] == 'robots')) {
                    $errors[] = array('MANUAL_META');
                }
                if ((isset($attributes['http-equiv'])) && (isset($attributes['content'])) && (strtolower($attributes['http-equiv']) == 'content-type') && ((strpos($attributes['content'], 'text/html;') !== false) || (strpos($attributes['content'], 'application/xhtml+xml;') !== false)) && (strpos($attributes['content'], 'charset=') !== false)) {
                    $GLOBALS['FOUND_CONTENTTYPE'] = true;
                }
                if (!empty($attributes['content'])) {
                    if ((isset($attributes['name'])) && ($attributes['name'] == 'keywords')) {
                        $GLOBALS['FOUND_KEYWORDS'] = true;
                    }
                    if ((isset($attributes['name'])) && ($attributes['name'] == 'description')) {
                        $GLOBALS['FOUND_DESCRIPTION'] = true;
                    }
                }
                break;

            case 'blockquote':
                if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
                    $errors[] = array('MANUAL_WCAG_SEMANTIC_BLOCKQUOTE');
                }
                break;

            case 'ul':
            case 'ol':
            case 'dl':
                if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
                    $errors[] = array('MANUAL_WCAG_SEMANTIC_LIST');
                }
                break;

            case 'script':
                if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
                    $errors[] = array('MANUAL_WCAG_ANIMATION');
                    $EXPECTING_TAG = 'noscript';
                }
                if (($GLOBALS['WEBSTANDARDS_JAVASCRIPT']) && ((!isset($attributes['type'])) || ((isset($attributes['type'])) && (($attributes['type'] == 'text/javascript') || (($attributes['type'] == 'application/x-javascript')))))) { // Validate CSS
                    if (function_exists('require_code')) {
                        require_code('webstandards_js_lint');
                    }
                    $content = substr($OUT, $POS, strpos($OUT, '</script>', $POS) - $POS); // While the </table> found may not be the closing tag to our table, we do know a <th> should occur before any such one (unless it's a really weird table layout)
                    $content = preg_replace('#((<![CDATA[)|(]]>)|(<!--)|(-->))#', '', $content);
                    $js_conformance = check_js($content, true);
                    if (is_array($js_conformance)) {
                        $errors = array_merge($errors, $js_conformance); // Some kind of error
                    }
                }
                break;

            case 'style':
                if (($GLOBALS['WEBSTANDARDS_CSS']) && ((!isset($attributes['type'])) || ((isset($attributes['type'])) && ($attributes['type'] == 'text/css')))) { // Validate CSS
                    $content = substr($OUT, $POS, strpos($OUT, '</style>', $POS) - $POS); // While the </table> found may not be the closing tag to our table, we do know a <th> should occur before any such one (unless it's a really weird table layout)
                    $content = preg_replace('#((<![CDATA[)|(]]>)|(<!--)|(-->))#', '', $content);
                    $css_conformance = _webstandards_css_sheet($content);
                    if (is_array($css_conformance)) {
                        $errors = array_merge($errors, $css_conformance); // Some kind of error
                    }
                }
                break;

            case 'area':
                global $AREA_LINKS;
                if (isset($attributes['href'])) {
                    $AREA_LINKS[@html_entity_decode($attributes['href'], ENT_QUOTES, get_charset())] = 1;
                }
                break;

            case 'base':
                global $URL_BASE;
                if (isset($attributes['href'])) {
                    $URL_BASE = @html_entity_decode($attributes['href'], ENT_QUOTES, get_charset());
                }
                break;

            case 'form':
                if ((isset($attributes['action'])) && (strpos($attributes['action'], '?') !== false) && (isset($attributes['method'])) && ($attributes['method'] == 'get')) {
                    $errors[] = array('XHTML_FORM_TYPE');
                }
                $GLOBALS['XHTML_FORM_ENCODING'] = isset($attributes['enctype']) ? $attributes['enctype'] : 'application/x-www-form-urlencoded';
                if ((isset($attributes['target'])) && ($attributes['target'] == '_blank') && ((!isset($attributes['title'])) || (strpos($attributes['title'], do_lang('LINK_NEW_WINDOW')) === false))) {
                    $errors[] = array('WCAG_BLANK');
                }
                if (($GLOBALS['XHTML_FORM_ENCODING'] == 'multipart/form-data') && (array_key_exists('method', $attributes)) && ($attributes['method'] == 'get')) {
                    $errors[] = array('XHTML_FORM_ENCODING_2');
                }
            // intentionally rolls on...

            case 'map':
            case 'iframe':
            case 'object': // Check that our 'name' attributes for frames etc are unique between selves and against IDs
                if (isset($attributes['name'])) {
                    global $ANCHORS_SEEN;
                    if (isset($ANCHORS_SEEN[$attributes['name']])) {
                        $errors[] = array('XHTML_A_NAME', $tag);
                    } else {
                        $ANCHORS_SEEN[$attributes['name']] = 1;
                    }

                    if ((!isset($attributes['id'])) || ((isset($attributes['id'])) && ($attributes['id'] != $attributes['name']))) {
                        $errors[] = array('XHTML_NAME_ID_DEPRECATED');
                    }
                }
                break;

            case 'input':
                if (isset($attributes['type'])) {
                    // Special case for missing 'name' in form elements
                    if (($attributes['type'] != 'image') && ($attributes['type'] != 'submit') && ($attributes['type'] != 'button') && ($attributes['type'] != 'reset')) {
                        if (!isset($attributes['name'])) {
                            $errors[] = array('XHTML_MISSING_ATTRIBUTE', $tag, 'name');
                        }
                    }

                    if ((isset($attributes['size'])) && (isset($attributes['type'])) && (($attributes['type'] == 'week') || ($attributes['type'] == 'hidden')/* || ($attributes['type'] == 'color') || ($attributes['type'] == 'number') Size would apply if browser is using non-HTML5 fallback*/ || ($attributes['type'] == 'month') || ($attributes['type'] == 'range') || ($attributes['type'] == 'radio') || ($attributes['type'] == 'checkbox'))) {
                        $errors[] = array('XHTML_NO_SIZE_FOR');
                    }

                    if (($attributes['type'] == 'image') && (!isset($attributes['alt']))) {
                        $errors[] = array('XHTML_MISSING_ATTRIBUTE', 'input', 'alt');
                    }

                    if (($attributes['type'] == 'checkbox') && (isset($attributes['id']))) {
                        $pre_content = substr($OUT, 0, $POS);
                        if (preg_match('#<label for="' . preg_quote($attributes['id'], '#') . '">[^:]+<input[^<>]+id="' . preg_quote($attributes['id'], '#') . '"#', $pre_content) != 0) {
                            //$errors[] = array('ACCESSIB_COLONS_IN_PRE_LABELS');   Annoying
                        }
                    }

                    if ($attributes['type'] == 'file') {
                        if (isset($attributes['value'])) {
                            $errors[] = array('XHTML_FILE_VALUE');
                        }
                        if (($GLOBALS['XHTML_FORM_ENCODING'] != 'multipart/form-data') && ($GLOBALS['XHTML_FORM_ENCODING'] != '')) {
                            $errors[] = array('XHTML_FORM_ENCODING');
                        }
                    } elseif (($attributes['type'] == 'text') && (!isset($attributes['value']))) {
                        $errors[] = array('XHTML_MISSING_ATTRIBUTE', $tag, 'value');
                    }
                }
                break;

            case 'select':
                $webstandards_check = function_exists('get_param_integer') ? get_param_integer('keep_webstandards_check', get_param_integer('webstandards_check', 0)) : 0;
                if ((isset($attributes['onchange'])) && (strpos($attributes['onchange'], 'form.submit()') !== false) && (strpos($attributes['onchange'], '/*guarded*/') === false) && ($webstandards_check == 0)) {
                    //$errors[] = array('WCAG_AUTO_SUBMIT_LIST'); Outdated, active JS now expected
                }
                break;

            case 'table':
                $content = strtolower(substr($OUT, $POS, strpos($OUT, '</table>', $POS) - $POS)); // While the </table> found may not be the closing tag to our table, we do know a <th> should occur before any such one (unless it's a really weird table layout)
                $th_count = substr_count($content, '<th');
                if (($th_count == 0) && (trim($content) != 'x')) {
                    $errors[] = array('WCAG_MISSING_TH');
                } else {
                    if (strpos($content, '<thead') === false) {
                        $tr_count = substr_count($content, '<tr');
                        if ($th_count > $tr_count) {
                            $errors[] = array('WCAG_HD_SPECIAL');
                        }
                    }
                }
                break;

            case 'thead':
                $array_pos = array_search('table', array_reverse($TAG_STACK));
                if ($array_pos !== false) {
                    $array_pos = count($TAG_STACK) - $array_pos - 1;
                }
                break;

            case 'tfoot':
                $array_pos = array_search('table', array_reverse($TAG_STACK));
                if ($array_pos !== false) {
                    $array_pos = count($TAG_STACK) - $array_pos - 1;
                }
                break;

            case 'th':
                $array_pos = array_search('table', array_reverse($TAG_STACK));
                if ($array_pos !== false) {
                    $array_pos = count($TAG_STACK) - $array_pos - 1;
                }

                /* We used to enforce th length for accessibility, but this is impractical since 'abbr' attribute was dropped in HTML5
                if (!isset($attributes['abbr'])) {
                    $content = trim(substr($OUT, $POS, strpos($OUT, '</th>', $POS) - $POS)); // This isn't perfect - In theory a th could contain a table itself: but it's not very semantic if it does
                    if (strlen(trim(@html_entity_decode(strip_tags($content), ENT_QUOTES, get_charset()))) > 40) {
                        $errors[] = array('WCAG_TH_TOO_LONG');
                    }
                }
                */
                break;

            case 'a':
                // Handle empty tag check for <a> (couldn't handle with normal case due to complexity)
                if ((!isset($attributes['id'])) && (!isset($attributes['title'])) && (substr($OUT, $POS, 4) == '</a>')) {
                    $errors[] = array('XHTML_EMPTY_TAG', $tag);
                }
                break;

            case 'img':
                if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (!isset($attributes['width']))) {
                    $errors[] = array('XHTML_WIDTH');
                }
                if ((isset($attributes['longdesc'])) && (!isset($attributes['dlink']))) {
                    $errors[] = array('WCAG_LONGTEXT_DLINK');
                }
                if ((isset($attributes['alt'])) && (isset($attributes['src'])) && ($attributes['alt'] != '') && ($attributes['alt'] == $attributes['src'])) {
                    $errors[] = array('XHTML_MISSING_ATTRIBUTE', 'img', 'alt');
                }
                break;
        }

        /*if (($tag[0]=='h') && (is_numeric(substr($tag,1))))   Excessive check, heading order gaps are okay as long as order is still logical
        {
            global $LAST_HEADING;
            if ($LAST_HEADING < intval(substr($tag, 1)) - 1) {
                $errors[] = array('WCAG_HEADING_ORDER');
            }
            $LAST_HEADING = intval(substr($tag, 1));
        }*/

        if (isset($attributes['accesskey'])) {
            $this_href = isset($attributes['href']) ? $attributes['href'] : uniqid('', true);
            if ((isset($KEYS_SEEN[$attributes['accesskey']])) && ($KEYS_SEEN[$attributes['accesskey']] != $this_href)) {
                $errors[] = array('WCAG_ACCESSKEY_UNIQUE');
            }
            $KEYS_SEEN[$attributes['accesskey']] = $this_href;
        }
        if (isset($attributes['tabindex'])) {
            if ((in_array($attributes['tabindex'], $TABS_SEEN)) && ($attributes['tabindex'] != 'x')) {
                $last = array_pop($TABS_SEEN);
                if ($last != $attributes['tabindex']) { // We do allow repeating of tabindexes as long as they are next to each other
                    $errors[] = array('WCAG_TABINDEX_UNIQUE');
                } else {
                    array_push($TABS_SEEN, $last);
                }
            }
            $TABS_SEEN[] = $attributes['tabindex'];
        }
    }

    return $errors;
}

/**
 * Checks a tag's inline/block/normal nesting situations.
 *
 * @param  string $tag The name of the tag to check
 * @param  map $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?list Array of errors (null: none)
 * @ignore
 */
function _check_blockyness($tag, $attributes, $self_close, $close)
{
    global $THE_DOCTYPE, $BLOCK_CONSTRAIN, $XML_CONSTRAIN, $TAGS_DEPRECATE_ALLOW, $PARENT_TAG, $TAGS_INLINE, $TAGS_BLOCK, $TAGS_NORMAL, $TAGS_INLINE_DEPRECATED, $TAGS_BLOCK_DEPRECATED, $TAGS_NORMAL_DEPRECATED, $IDS_SO_FAR, $ANCESTER_BLOCK, $ANCESTER_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $UNDER_XMLNS;

    $errors = array();

    $dif = $close ? -1 : 1;
    if ($self_close) {
        $dif = 0;
    }
    if ((isset($TAGS_BLOCK[$tag])) || (isset($TAGS_BLOCK_DEPRECATED[$tag]))) {
        if (($ANCESTER_INLINE != 0) && ($BLOCK_CONSTRAIN)) {
            $errors[] = array('XHTML_ANCESTER_BLOCK_INLINE', $tag);
        }
        $ANCESTER_BLOCK += $dif;
        if (isset($TAGS_BLOCK_DEPRECATED[$tag])) {
            $errors[] = array($TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_TAG' : 'XHTML_UNKNOWN_TAG', $tag);
        }
    } elseif ((isset($TAGS_INLINE[$tag])) || (isset($TAGS_INLINE_DEPRECATED[$tag]))) {
        //if (($BLOCK_CONSTRAIN) && ($PARENT_TAG != 'span') && ((isset($TAGS_NORMAL[$PARENT_TAG])) || ((isset($TAGS_NORMAL_DEPRECATED[$PARENT_TAG]))))) $errors[] = array('XHTML_ANCESTER_INLINE_NORMAL', $tag); This restriction isn't really a proper one, some checkers seem to have it but it is not used anymore (XHTML5+) and pretty silly
        if ($tag != 'label') {
            $ANCESTER_INLINE += $dif;
        }
        if (isset($TAGS_INLINE_DEPRECATED[$tag])) {
            $errors[] = array($TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_TAG' : 'XHTML_UNKNOWN_TAG', $tag);
        }
    } elseif ((isset($TAGS_NORMAL[$tag])) || (isset($TAGS_NORMAL_DEPRECATED[$tag]))) {
        if ($tag == 'title') {
            $ANCESTER_BLOCK += $dif;
        }
        if (($tag == 'iframe') && (($THE_DOCTYPE == DOCTYPE_XHTML_STRICT) || ($THE_DOCTYPE == DOCTYPE_XHTML_11))) {
            $errors[] = array('XHTML_UNKNOWN_TAG', $tag);
        }
        if (isset($TAGS_NORMAL_DEPRECATED[$tag])) {
            $errors[] = array($TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_TAG' : 'XHTML_UNKNOWN_TAG', $tag);
        }
    } elseif (!$close) {
        if (!$UNDER_XMLNS) {
            $errors[] = array('XHTML_UNKNOWN_TAG', $tag);
        }
    }

    return ($errors == array()) ? null : $errors;
}

/**
 * Checks a tag's attributes.
 *
 * @param  string $tag The name of the tag to check
 * @param  map $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?list Array of errors (null: none)
 * @ignore
 */
function _check_attributes($tag, $attributes, $self_close, $close)
{
    global $PSPELL_LINK, $THE_LANGUAGE, $XML_CONSTRAIN, $TAGS_DEPRECATE_ALLOW, $THE_DOCTYPE, $HYPERLINK_URLS, $CRAWLED_URLS, $EMBED_URLS, $TAGS_INLINE, $TAGS_BLOCK, $TAGS_NORMAL, $TAGS_INLINE_DEPRECATED, $TAGS_BLOCK_DEPRECATED, $TAGS_NORMAL_DEPRECATED, $TAG_ATTRIBUTES, $IDS_SO_FAR, $ANCESTER_BLOCK, $ANCESTER_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $TAG_ATTRIBUTES_REQUIRED;

    $errors = array();

    $stub = $tag . '.';
    foreach ($attributes as $attribute => $value) {
        $lattribute = strtolower($attribute);
        if ($lattribute != $attribute) {
            if ($XML_CONSTRAIN) {
                $errors[] = array('XHTML_CASE_ATTRIBUTE', $tag, $attribute);
            }
            $attribute = $lattribute;
        }

        if (($attribute == 'lang') || ($attribute == 'xml:lang')) {
            $THE_LANGUAGE = $value;
        }

        if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (($value == 'TODO') || (strpos($value, 'Lorem ') !== false))) {
            $errors[] = array('XHTML_PLACEHOLDER');
        }

        if ((!isset($TAG_ATTRIBUTES[$stub . $attribute])) && (!isset($TAG_ATTRIBUTES['*.' . $attribute])) && (!isset($TAG_ATTRIBUTES_REQUIRED[$stub . $attribute]))) {
            if ((!isset($TAGS_BLOCK[$tag])) && (!isset($TAGS_INLINE[$tag])) && (!isset($TAGS_NORMAL[$tag]))) {
                continue;
            }
            if ((!isset($TAGS_BLOCK_DEPRECATED[$tag])) && (!isset($TAGS_INLINE_DEPRECATED[$tag])) && (!isset($TAGS_NORMAL_DEPRECATED[$tag]))) {
                continue;
            }
            if (strpos($attribute, ':') !== false) {
                continue;
            }
            if (substr($attribute, 0, 5) == 'data-') {
                continue;
            }

            if ($tag == 'embed') continue;

            $errors[] = array('XHTML_UNKNOWN_ATTRIBUTE', $tag, $attribute);
            continue;
        } else {
            if (isset($TAG_ATTRIBUTES_REQUIRED[$stub . $attribute])) {
                $errors[] = array($TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_ATTRIBUTE' : 'XHTML_UNKNOWN_ATTRIBUTE', $tag, $attribute);
            }

            if (($attribute == 'target') && (($THE_DOCTYPE == DOCTYPE_XHTML_STRICT) || ($THE_DOCTYPE == DOCTYPE_XHTML_11))) {
                $errors[] = array('XHTML_UNKNOWN_ATTRIBUTE', $tag, $attribute);
            }
        }

        if ((($attribute == 'alt') || ($attribute == 'title') || (($attribute == 'content') && (array_key_exists('http-equiv', $attributes)) && ((strtolower($attributes['http-equiv']) == 'description') || (strtolower($attributes['http-equiv']) == 'keywords')))) && (function_exists('pspell_new')) && (!empty($GLOBALS['SPELLING'])) && ($value != '')) {
            $_value = @html_entity_decode($value, ENT_QUOTES, get_charset());
            $errors = array_merge($errors, check_spelling($_value));
        }

        //if (($attribute == 'alt') && ($tag != 'input') && (strlen(strip_tags($value)) > 150)) $errors[] = array('WCAG_ATTRIBUTE_TOO_LONG', $attribute);

        if (($attribute == 'href') || ($attribute == 'src') || (($attribute == 'data') && ($tag == 'object'))) {
            $CRAWLED_URLS[] = @html_entity_decode($value, ENT_QUOTES, get_charset());
            if ($tag == 'a') {
                $HYPERLINK_URLS[] = @html_entity_decode($value, ENT_QUOTES, get_charset());
            }
        }
        if ((($attribute == 'src') && ($tag == 'embed')) || (($attribute == 'src') && ($tag == 'script')) || (($attribute == 'src') && ($tag == 'iframe')) || (($attribute == 'src') && ($tag == 'img')) || (($attribute == 'href') && ($tag == 'link') && (isset($attributes['rel'])) && ($attributes['rel'] == 'stylesheet')) || (($attribute == 'data') && ($tag == 'object')) || (($attribute == 'code') && ($tag == 'applet'))) {
            $EMBED_URLS[] = @html_entity_decode($value, ENT_QUOTES, get_charset());
        }

        if (($attribute == 'href') && (@strtolower(@$value[0]) == 'j') && (strtolower(substr($value, 0, 11)) == 'javascript:')) {
            $errors[] = array('XHTML_BAD_ATTRIBUTE_VALUE', $attribute, $value, 'no js href');
        }

        if (isset($TAG_ATTRIBUTES[$stub . $attribute])) {
            $reg_exp = $TAG_ATTRIBUTES[$stub . $attribute];
        } else {
            $reg_exp = $TAG_ATTRIBUTES['*.' . $attribute];
        }

        if (($reg_exp != '(.|\n)*') && (preg_match('#^' . $reg_exp . '$#s', $value) == 0) && ($value != 'x')) {
            $errors[] = array('XHTML_BAD_ATTRIBUTE_VALUE', $attribute, $value, $reg_exp);
        }

        if (($attribute == 'style') && ($GLOBALS['WEBSTANDARDS_CSS'])) { // Validate CSS
            if ((!function_exists('do_template')) && (strpos($value, '{') === false) && (strpos($value, 'float:') === false) && (strpos($value, ': none') === false) && (strpos($value, ': inline') === false) && (strpos($value, ': block') === false)) {
                $errors[] = array('CSS_INLINE_STYLES');
            }

            $css_conformance = _webstandards_css_class($value, 0);
            if (is_array($css_conformance)) {
                $errors = array_merge($errors, $css_conformance); // Some kind of error
            }
        }

        if ($attribute == 'id') { // Check we don't have duplicate IDs
            if (isset($IDS_SO_FAR[strtolower($value)])) { // strtolower is for compatibility - in reality, IDs are not meant to be case insensitive
                $errors[] = array('XHTML_DUPLICATED_ID', $value);
            }
            $IDS_SO_FAR[strtolower($value)] = 1;
        }
    }

    return ($errors == array()) ? null : $errors;
}

/**
 * Checks the spelling of some text.
 *
 * @param  string $value The text
 * @return list Array of errors
 */
function check_spelling($value)
{
    global $THE_LANGUAGE;
    $lang = strtolower($THE_LANGUAGE);

    require_code('spelling');
    $misspellings = run_spellcheck($value, $lang);

    $errors = array();
    foreach (array_keys($misspellings) as $word) {
        $errors[] = array('XHTML_SPELLING', $word);
    }
    return $errors;
}

/**
 * Checks the content under a tag's external references.
 *
 * @param  string $tag The name of the tag to check
 * @param  map $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?list Array of errors (null: none)
 * @ignore
 */
function _check_externals($tag, $attributes, $self_close, $close)
{
    if ((function_exists('get_param_integer')) && (get_param_integer('keep_ext_check', null) === 0)) {
        return null;
    }

    unset($self_close);
    unset($close);

    global $VALIDATED_ALREADY, $IDS_SO_FAR, $ANCESTER_BLOCK, $ANCESTER_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG;

    $errors = array();

    if (($tag == 'link') && ($GLOBALS['WEBSTANDARDS_CSS']) && (!$GLOBALS['NO_XHTML_LINK_FOLLOW']) && (isset($attributes['href'])) && (isset($attributes['type'])) && ($attributes['type'] == 'text/css') && (!isset($VALIDATED_ALREADY[$attributes['href']]))) { // Validate CSS
        $VALIDATED_ALREADY[$attributes['href']] = 1;
        $url = qualify_url($attributes['href'], $GLOBALS['URL_BASE']);
        if ($url != '') {
            $sheet = http_get_contents($url, array('trigger_error' => false));
            if ($sheet !== null) {
                $css_conformance = _webstandards_css_sheet($sheet);
                if (is_array($css_conformance)) {
                    $errors = array_merge($errors, $css_conformance); // Some kind of error
                }
            }
        }
    }

    if (($GLOBALS['WEBSTANDARDS_JAVASCRIPT']) && ($tag == 'script') && (!$GLOBALS['NO_XHTML_LINK_FOLLOW']) && (isset($attributes['src'])) && ((!isset($attributes['type'])) || (isset($attributes['type'])) && (($attributes['type'] == 'text/javascript') || ($attributes['type'] == 'application/x-javascript'))) && (!isset($VALIDATED_ALREADY[$attributes['src']]))) { // Validate CSS
        $VALIDATED_ALREADY[$attributes['src']] = 1;
        $url = qualify_url($attributes['src'], $GLOBALS['URL_BASE']);
        if ($url != '') {
            $http_result = cms_http_request($url, array('trigger_error' => false));
            if ($http_result->data !== null) {
                require_code('character_sets');
                $js = convert_to_internal_encoding($http_result->data, $http_result->charset);

                $VALIDATED_ALREADY[$attributes['src']] = 1;

                if (function_exists('require_code')) {
                    require_code('webstandards_js_lint');
                }
                $js_conformance = check_js($js, true);
                if (is_array($js_conformance)) {
                    $errors = array_merge($errors, $js_conformance); // Some kind of error
                }
            }
        }
    }

    if (($tag == 'iframe') && (!empty($attributes['src'])) && (!$GLOBALS['NO_XHTML_LINK_FOLLOW']) && (!isset($VALIDATED_ALREADY[$attributes['src']]))) { // Validate iframe's
        $VALIDATED_ALREADY[$attributes['src']] = 1;
        $url = qualify_url($attributes['src'], $GLOBALS['URL_BASE']);
        if ($url != '') {
            $http_result = cms_http_request($url, array('trigger_error' => false)); // Sometimes disabled due to my iframe producing a weird PHP exception, that was stopping me working
            if (($http_result->data !== null) && ($http_result->data != '')) {
                require_code('character_sets');
                $iframe = convert_to_internal_encoding($http_result->data, $http_result->charset);

                if (($http_result->download_mime_type == 'text/html') || ($http_result->download_mime_type == 'application/xhtml+xml')) {
                    global $EXTRA_CHECK;
                    $EXTRA_CHECK[] = $iframe;
                }
            }
        }
    }

    return ($errors == array()) ? null : $errors;
}

/**
 * Checks link accessibility.
 *
 * @param  string $tag The name of the tag to check
 * @param  map $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?list Array of errors (null: none)
 * @ignore
 */
function _check_link_accessibility($tag, $attributes, $self_close, $close)
{
    global $IDS_SO_FAR, $ANCESTER_BLOCK, $ANCESTER_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $TAG_RANGES, $WEBSTANDARDS_MANUAL;

    $errors = array();

    // Check captioning
    global $A_LINKS;
    if (!isset($attributes['title'])) {
        $title = '';
    } else {
        $title = $attributes['title'];
    }
    $content = strtolower(substr($OUT, $POS, strpos($OUT, '</a>', $POS) - $POS));
    if ((isset($attributes['target'])) && ($attributes['target'] == '_blank') && (function_exists('do_lang')) && (strpos($content, do_lang('LINK_NEW_WINDOW')) === false) && (strpos($title, do_lang('LINK_NEW_WINDOW')) === false)) {
        $errors[] = array('WCAG_BLANK');
    }
    if (substr($content, 0, 4) != '<img') {
        $filtered_href = str_replace('/index.php', '', $attributes['href']);
        $filtered_href = preg_replace('#&keep_session=[^&]*#', '', $filtered_href);

        if (($WEBSTANDARDS_MANUAL) && (isset($A_LINKS[$title])) && (isset($A_LINKS[$title][$content])) && ($A_LINKS[$title][$content] != $attributes['href']) && ($A_LINKS[$title][$content] != $filtered_href)) {
            $errors[] = array('WCAG_DODGY_LINK', $A_LINKS[$title][$content]);
        }
        $bad_strings = array('click'/*,'here'*/);
        $_content = strip_tags($content);
        if (trim($_content) != $_content) {
            $errors[] = array('XHTML_A_SPACES');
        }
        if (($_content == $content) && (strlen($content) < 12)) {
            $in_strings = str_word_count($_content, 1);
            foreach ($bad_strings as $string) {
                if (in_array($string, $in_strings) !== false) {
                    $errors[] = array('WCAG_DODGY_LINK_2', $string);
                }
            }
        }
        if ($title == '') {
            if (strtolower($content) == 'more') {
                $errors[] = array('WCAG_DODGY_LINK_2', $string);
            }
        }
        $A_LINKS[$title][$content] = $filtered_href;
    }

    return ($errors == array()) ? null : $errors;
}

/**
 * Checks form field labelling.
 *
 * @param  string $tag The name of the tag to check
 * @param  map $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?list Array of errors (null: none)
 * @ignore
 */
function _check_labelling($tag, $attributes, $self_close, $close)
{
    global $TAG_STACK, $IDS_SO_FAR, $ANCESTER_BLOCK, $ANCESTER_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG;

    $errors = array();

    global $FOR_LABEL_IDS, $FOR_LABEL_IDS_2, $INPUT_TAG_IDS;
    if (($tag == 'td')/* || ($tag == 'div')*/) {
        //$FOR_LABEL_IDS = array(); // Can't work across table cells      Actually this is an ancient and lame restriction that hurts accessibility more than helping it
    }
    if (($tag == 'label') && (isset($attributes['for']))) {
        $FOR_LABEL_IDS[$attributes['for']] = 1;
        $FOR_LABEL_IDS_2[$attributes['for']] = 1;
    } // Check we that all input tags have labels
    elseif ((!$close) && (($tag == 'textarea') || ($tag == 'select') || (($tag == 'input') && ((!isset($attributes['type'])) || (($attributes['type'] != 'hidden') && ($attributes['type'] != 'button') && ($attributes['type'] != 'image') && ($attributes['type'] != 'reset') && ($attributes['type'] != 'submit')))))) {
        if (isset($attributes['id'])) {
            $INPUT_TAG_IDS[$attributes['id']] = 1;
        }

        if ((!isset($attributes['style'])) || (($attributes['style'] != 'display:none') && ($attributes['style'] != 'display: none'))) {
            if ($tag == 'input') {
                if (!isset($attributes['type'])) {
                    return null;
                }

                if ((($attributes['type'] == 'radio') || ($attributes['type'] == 'checkbox')) && (isset($attributes['onchange'])) && ($GLOBALS['WEBSTANDARDS_COMPAT'])) {
                    $errors[] = array('XHTML_IE_ONCHANGE');
                }
            }

            if (!isset($attributes['id'])) {
                $attributes['id'] = 'unnamed_' . strval(mt_rand(0, 10000));
            }

            if ((!isset($FOR_LABEL_IDS[$attributes['id']])) && ($attributes['id'] != 'x') && (preg_match('#<label[^<>]+for="' . preg_quote($attributes['id'], '#') . '"#', $OUT) == 0)) {
                $errors[] = array('WCAG_NO_INPUT_LABEL', $attributes['id']);
            }
        }
    }

    return ($errors == array()) ? null : $errors;
}

/**
 * Checks a CSS style sheet (high level).
 *
 * @param  string $data The data of the style sheet
 * @return ?map Error information (null: no error)
 */
function check_css($data)
{
    if (!isset($GLOBALS['MAIL_MODE'])) {
        $GLOBALS['MAIL_MODE'] = false;
    }
    $_errors = _webstandards_css_sheet($data);
    if ($_errors === null) {
        $_errors = array();
    }
    $errors = array();
    global $POS, $OUT;
    global $CSS_TAG_RANGES, $CSS_VALUE_RANGES;
    $OUT = $data;

    foreach ($_errors as $error) {
        $POS = 0;
        $errors[] = _xhtml_error($error[0], array_key_exists(1, $error) ? $error[1] : '', array_key_exists(2, $error) ? $error[2] : '', array_key_exists(3, $error) ? $error[3] : '', false, $error['pos']);
    }
    return array('level_ranges' => null, 'tag_ranges' => $CSS_TAG_RANGES, 'value_ranges' => $CSS_VALUE_RANGES, 'errors' => $errors);
}

/**
 * Checks a CSS style sheet.
 *
 * @param  string $data The data of the style sheet
 * @return ?map Error information (null: no error)
 * @ignore
 */
function _webstandards_css_sheet($data)
{
    global $CSS_TAG_RANGES, $CSS_VALUE_RANGES, $VALIDATED_ALREADY;
    $CSS_TAG_RANGES = array();
    $CSS_VALUE_RANGES = array();

    $errors = array();

    $len = strlen($data);
    $status = CSS_NO_MANS_LAND;
    $line = 0;
    $class_before_comment = null;
    $class = '';
    $at_rule = '';
    $at_rule_block = '';
    $brace_level = 0;
    $i = 0;
    $class_start_line = null;
    $class_start_i = null;
    $class_name = '';
    $in_comment = false;
    $quoting = false;
    while ($i < $len) {
        $next = $data[$i];
        $val = ord($next);
        if (($next == '_') || ($next == '.') || ($next == '-') || (($val >= 65) && ($val <= 90)) || (($val >= 97) && ($val <= 122)) || (($val >= 48) && ($val <= 57))) {
            $alpha_numeric = true;
            $whitespace = false;
            $comment_starting = false;
        } else {
            $alpha_numeric = false;
            $whitespace = (($next == "\t") || ($val == 13) || ($val == 10) || ($next == ' '));
            $comment_starting = (($next == '/') && ($i < $len - 2) && ($data[$i + 1] == '*'));
        }

        switch ($status) {
            case CSS_AT_RULE:
                if ($next == '{') {
                    $brace_level = 0;
                    $status = CSS_AT_RULE_BLOCK;
                    $at_rule_block = '';
                } elseif ($next == ';') {
                    $status = CSS_NO_MANS_LAND;
                    if (substr($at_rule, 0, 6) == 'import ') {
                        $count = substr_count($at_rule, '"');
                        $first = strpos($at_rule, '"') + 1;
                        if ($count < 2) {
                            $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i);
                            return $errors;
                        }
                        $at_file = substr($at_rule, $first, (strpos($at_rule, '"', $first) - 1) - $first);
                        if (!isset($VALIDATED_ALREADY[$at_file])) {
                            $at_file = qualify_url($at_file, $GLOBALS['URL_BASE']);
                            if ($at_file != '') {
                                $data2 = http_get_contents($at_file, array('trigger_error' => false));
                                if ($data2 !== null) {
                                    $css_tag_ranges_backup = $CSS_TAG_RANGES;
                                    $css_value_ranges_backup = $CSS_VALUE_RANGES;
                                    $test = _webstandards_css_sheet($data2);
                                    $CSS_TAG_RANGES = $css_tag_ranges_backup;
                                    $CSS_VALUE_RANGES = $css_value_ranges_backup;
                                    if (is_array($test)) {
                                        foreach ($test as $error) {
                                            $error['pos'] = $i;
                                            $errors[] = $error;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    $at_rule .= $next;
                }
                break;

            case CSS_AT_RULE_BLOCK:
                if ($next == '{') {
                    ++$brace_level;
                    $at_rule_block .= $next;
                } elseif (($next == '}') && ($brace_level == 0)) {
                    $status = CSS_NO_MANS_LAND;
                    if (substr($at_rule, 0, 6) == 'media ') {
                        $css_tag_ranges_backup = $CSS_TAG_RANGES;
                        $css_value_ranges_backup = $CSS_VALUE_RANGES;
                        $test = _webstandards_css_sheet($at_rule_block);
                        $CSS_TAG_RANGES = $css_tag_ranges_backup;
                        $CSS_VALUE_RANGES = $css_value_ranges_backup;
                        if (is_array($test)) {
                            foreach ($test as $error) {
                                $error['pos'] = $i;
                                $errors[] = $error;
                            }
                        }
                    }
                } elseif ($next == '}') {
                    $brace_level--;
                    $at_rule_block .= $next;
                } else {
                    $at_rule_block .= $next;
                }
                break;

            case CSS_NO_MANS_LAND:
                if ($whitespace) {
                    // Continuing
                } elseif (($next == '.') || ($next == ':') || ($next == '#') || ($alpha_numeric)) {
                    if ($data[$i + 1] == ':') { // e.g. "::selection"
                        if (!empty($GLOBALS['PEDANTIC'])) {
                            $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i);
                        }
                        $i++;
                    }
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = '';
                } elseif ($next == '@') {
                    $status = CSS_AT_RULE;
                    $at_rule = '';
                } elseif ($comment_starting) {
                    $status = CSS_IN_COMMENT;
                    $class_before_comment = CSS_NO_MANS_LAND;
                } elseif ($next == '*') {
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = '*';
                } else {
                    $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i);
                }
                break;

            case CSS_EXPECTING_IDENTIFIER:
                if ($comment_starting) {
                    $status = CSS_IN_COMMENT;
                    $class_before_comment = CSS_EXPECTING_IDENTIFIER;
                } elseif ($whitespace) {
                    // Continuing
                } elseif ($next == '*') {
                    $status = CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS;
                } elseif (($next == '.') || ($next == ':') || ($next == '#') || ($alpha_numeric)) {
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = $alpha_numeric ? $next : '';
                } else {
                    $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i);
                }
                break;

            case CSS_IN_COMMENT:
                if (($next == '*') && ($i != $len - 1) && ($data[$i + 1] == '/')) {
                    $status = $class_before_comment;
                    ++$i;
                }
                break;

            case CSS_IN_PSEUDOCLASS_EXPRESSION:
                if ($next == ')') {
                    $status = CSS_IN_IDENTIFIER;
                }
                break;

            case CSS_IN_IDENTIFIER:
                if ($next == '(') {
                    $status = CSS_IN_PSEUDOCLASS_EXPRESSION;
                    break;
                }
                if (($alpha_numeric) || ($next == ':') || ($next == '#')) {
                    $class_name .= $next;
                } else {
                    // Test class name
                    $cnt = substr_count($class_name, ':');
                    if ($cnt > 0) {
                        $matches = array();
                        $num_matches = preg_match_all('#:([\w-]+)(\([^()]*\))?#', $class_name, $matches);
                        for ($j = 0; $j < $num_matches; $j++) {
                            $pseudo = $matches[1][$j];
                        }
                    }

                    if ($whitespace) {
                        $status = CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS;
                    } elseif (($next == ',') || ($next == '>') || ($next == '+') || ($next == '~')) {
                        $status = CSS_EXPECTING_IDENTIFIER;
                    } elseif ($next == '{') {
                        $status = CSS_IN_CLASS;
                        $class_start_line = $line;
                        $class_start_i = $i;
                        $class = '';
                    } else {
                        $matches = array();
                        if (($next == '[') && (preg_match('#\[(\w+|)?\w+([$*~|^]?="[^;"]*")?\]#', $data, $matches, 0, $i) == 1)) {
                            $i += strlen($matches[0]) - 1;
                        } else {
                            $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i);
                        }
                    }
                }
                break;

            case CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS:
                if ($next == '{') {
                    $status = CSS_IN_CLASS;
                    $class_start_line = $line;
                    $class_start_i = $i;
                    $class = '';
                } elseif ($next == '*') {
                    // Continuing
                } elseif ($whitespace) {
                    // Continuing
                } elseif (($next == ',') || ($next == '>') || ($next == '+') || ($next == '~')) {
                    $status = CSS_EXPECTING_IDENTIFIER;
                } elseif ($comment_starting) {
                    $status = CSS_IN_COMMENT;
                    $class_before_comment = CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS;
                } elseif (($next == '.') || ($next == ':') || ($next == '#') || ($alpha_numeric)) {
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = '';
                } elseif ($next == '[') {
                    $i--;
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = '';
                } else {
                    $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i);
                }
                break;

            case CSS_IN_CLASS:
                if ($quoting) {
                    if ((($next == '"') || ($next == "'")) && ($data[$i - 1] != "\\")) {
                        $quoting = !$quoting;
                    }
                    $class .= $next;
                } elseif ($in_comment) {
                    $comment_ending = (($next == '*') && ($i < $len - 2) && ($data[$i + 1] == '/'));
                    if ($comment_ending) {
                        $in_comment = false;
                    }
                    $class .= $next;
                } elseif ($next == '}') {
                    $status = CSS_NO_MANS_LAND;
                    $test = _webstandards_css_class($class, $class_start_i, $class_start_line + 1);
                    if (is_array($test)) {
                        $errors = array_merge($errors, $test);
                    }
                } elseif ($comment_starting) {
                    $in_comment = true;
                    $class .= $next;
                } elseif ((($next == '"') || ($next == "'")) && ($data[$i - 1] != "\\")) {
                    $quoting = true;
                    $class .= $next;
                } elseif ($next == '{') {
                    $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER_CLASS', 1 => $next, 2 => integer_format($line), 'pos' => $i);
                    return $errors;
                } else {
                    $class .= $next;
                }
                break;
        }

        if ($val == 10) {
            ++$line;
        }

        ++$i;
    }

    if ($status != CSS_NO_MANS_LAND) {
        $errors[] = array(0 => 'CSS_UNEXPECTED_TERMINATION', 'pos' => $i);
        return $errors;
    }

    return ($errors == array()) ? null : $errors;
}

/**
 * Checks a CSS class.
 *
 * @param  string $data The data of the CSS class
 * @param  integer $_i Current parse position
 * @param  integer $line The higher-level line number we are checking for (to give better debug output)
 * @return ?map Error information (null: no error)
 * @ignore
 */
function _webstandards_css_class($data, $_i, $line = 0)
{
    $errors = array();

    global $CSS_TAG_RANGES;
    global $CSS_VALUE_RANGES;

    $len = strlen($data);
    $i = 0;
    $key = '';
    $value = '';
    $status = _CSS_NO_MANS_LAND;
    $class_before_comment = null;
    $quoting = false;
    while ($i < $len) {
        $next = $data[$i];
        $val = ord($next);
        $alpha_numeric = ($next == '_') || ($next == '.') || ($next == '-') || (($val >= 65) && ($val <= 90)) || (($val >= 97) && ($val <= 122)) || (($val >= 48) && ($val <= 57));
        $whitespace = (($next == "\t") || ($val == 13) || ($val == 10) || ($next == ' '));
        $comment_starting = (($next == '/') && ($i != $len - 2) && ($i + 1 < $len) && ($data[$i + 1] == '*'));

        switch ($status) {
            case _CSS_NO_MANS_LAND:
                if ($alpha_numeric) {
                    $CSS_TAG_RANGES[] = array($_i + $i + 1, $_i + $i + 2);
                    $status = _CSS_IN_PROPERTY_KEY;
                    $key = $next;
                } elseif (($whitespace) || ($next == ';')) { // ; is unusual here, but allowed; It occurs when we substitute nothing into a part of a style attribute
                    // Continuing
                } elseif ($comment_starting) {
                    $class_before_comment = $status;
                    $status = _CSS_IN_COMMENT;
                } else {
                    $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER_CLASS', 1 => $next, 2 => integer_format($line), 'pos' => $_i);
                }
                break;

            case _CSS_IN_COMMENT:
                if (($next == '*') && ($i != $len - 1) && ($data[$i + 1] == '/')) {
                    $status = $class_before_comment;
                    ++$i;
                }
                break;

            case _CSS_IN_PROPERTY_KEY:
                if ($next == ':') {
                    $status = _CSS_IN_PROPERTY_BETWEEN;
                    $value = '';
                } elseif ($alpha_numeric) {
                    $key .= $next;
                    $CSS_TAG_RANGES[count($CSS_TAG_RANGES) - 1][1]++;
                }
                break;

            case _CSS_IN_PROPERTY_BETWEEN:
                if (!$whitespace) {
                    $status = _CSS_IN_PROPERTY_VALUE;
                    $CSS_VALUE_RANGES[] = array($_i + $i + 1, $_i + $i + 1);
                    $i--;
                }
                break;

            case _CSS_IN_PROPERTY_VALUE:
                if (($next == ';') && (!$quoting)) {
                    $test = _check_css_value($key, $value, $_i);
                    if (is_array($test)) {
                        $errors[] = $test;
                    }
                    $status = _CSS_NO_MANS_LAND;
                } elseif ($comment_starting) {
                    $class_before_comment = $status;
                    $status = _CSS_IN_COMMENT;
                } elseif (($val == 10) || ($val == 13)) {
                    $status = _CSS_EXPECTING_END;
                } else {
                    if ((($next == '"') || ($next == "'")) && ($data[$i - 1] != "\\")) {
                        $quoting = !$quoting;
                    }
                    $value .= $next;
                    $CSS_VALUE_RANGES[count($CSS_VALUE_RANGES) - 1][1]++;
                }
                break;

            case _CSS_EXPECTING_END:
                if (!$whitespace) {
                    $errors[] = array(0 => 'CSS_UNEXPECTED_CHARACTER_CLASS', 1 => $next, 2 => integer_format($line), 'pos' => $_i);
                    return $errors;
                }
                break;
        }

        if ($val == 10) {
            ++$line;
        }

        ++$i;
    }

    if (($status != _CSS_NO_MANS_LAND) && ($status != _CSS_IN_PROPERTY_VALUE) && ($status != _CSS_EXPECTING_END)) {
        $errors[] = array(0 => 'CSS_UNEXPECTED_TERMINATION_PROPERTY', 'pos' => $_i);
        return $errors;
    }

    if ($status == _CSS_IN_PROPERTY_VALUE) {
        $test = _check_css_value($key, $value, $_i);
        if (is_array($test)) {
            $errors[] = $test;
        }
    }

    return ($errors == array()) ? null : $errors;
}

/**
 * Checks a CSS attribute/value combination is appropriate.
 *
 * @param  string $key The name of the attribute
 * @param  string $value The value of the attribute
 * @param  integer $_i Current parse position
 * @return ?map Error information (null: no error)
 * @ignore
 */
function _check_css_value($key, $value, $_i)
{
    $value = str_replace(' !important', '', $value);
    $value = trim($value);

    if (substr($value, 0, 11) == '!important ') {
        $value = substr($value, 11); // Strip off the important flag if it's present
    }

    $error = null;

    global $CSS_PROPERTIES;
    if (!isset($CSS_PROPERTIES[$key])) {
        if (substr($key, 0, 1) == '-') {
            return null;
        }
        return array(0 => 'CSS_UNKNOWN_PROPERTY', 1 => $key, 'pos' => $_i);
    } else {
        $reg_exp = $CSS_PROPERTIES[$key];
    }

    if ((preg_match('#^' . $reg_exp . '$#s', $value) == 0) && ($value != 'xpx') && ($value != 'x') && ($value != 'inherit') && ($value != 'initial') && (substr($value, 0, 5) != 'calc(')) {
        return array(0 => 'CSS_BAD_PROPERTY_VALUE', 1 => $key, 2 => $value, 3 => $reg_exp, 'pos' => $_i);
    }

    if ($GLOBALS['MAIL_MODE']) {
        if ($key == 'position') {
            return array(0 => 'MAIL_POSITIONING', 'pos' => $_i);
        }
        if (($key == 'width') && (substr($value, -2) == 'px') && (intval(substr($value, 0, strlen($value) - 2)) > 530)) {
            return array(0 => 'MAIL_WIDTH', 'pos' => $_i);
        }
    } else {
        if (!empty($GLOBALS['PEDANTIC'])) {
            if (($key == 'font-size') && (substr($value, -2) == 'px')) {
                return array(0 => 'CSS_PX_FONT', 'pos' => $_i);
            }
        }
    }

    return $error;
}
