<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2016

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Do a hashing, with support for our "ratcheting up" algorithm (i.e. lets the admin increase the complexity over the time, as CPU speeds get faster).
 *
 * @param  SHORT_TEXT $password The password in plain text
 * @param  SHORT_TEXT $salt The salt
 * @return SHORT_TEXT The salted&hashed password
 */
function ratchet_hash($password, $salt)
{
    // NB: We don't pass the salt separately, we let password_hash generate its own internal salt also (that builds into the hash). So it is double salted.
    return password_hash($salt . md5($password), PASSWORD_BCRYPT, array('cost' => intval(get_option('crypt_ratchet'))));
}

/**
 * Verify a password is correct by comparison of the hashed version.
 *
 * @param  SHORT_TEXT $password The password in plain text
 * @param  SHORT_TEXT $salt The salt
 * @param  SHORT_TEXT $pass_hash_salted The prior salted&hashed password, which will also include the algorithm/ratcheting level (unless it's old style, in which case we use non-ratcheted md5)
 * @param  integer $legacy_style Legacy hashing style to fallback to
 * @return boolean Whether the password if verified
 */
function ratchet_hash_verify($password, $salt, $pass_hash_salted, $legacy_style = 0)
{
    if (strpos($pass_hash_salted, '$') !== false) {
        return password_verify($salt . md5($password), $pass_hash_salted);
    }

    // LEGACY: Old-style md5'd password
    if ($legacy_style == PASSWORD_SALT) {
        return hash_equals($pass_hash_salted, md5($password . $salt));
    }
    return hash_equals($pass_hash_salted, md5($salt . md5($password)));
}

/**
 * Get a decent randomised salt.
 *
 * @return ID_TEXT The salt
 */
function produce_salt()
{
    // md5 used in all the below so that we get nice ASCII characters

    if (function_exists('random_bytes')) {
        $u = substr(md5(random_bytes(13)), 0, 13);
    } elseif ((function_exists('openssl_random_pseudo_bytes')) && (get_value('disable_openssl') !== '1')) {
        $u = substr(md5(openssl_random_pseudo_bytes(13)), 0, 13);
    } elseif (function_exists('password_hash')) { // password_hash will include a randomised component
        return substr(md5(password_hash(uniqid('', true), PASSWORD_BCRYPT, array('cost' => intval(get_option('crypt_ratchet'))))), 0, 13);
    } else {
        $u = substr(md5(uniqid(strval(get_secure_random_number()), true)), 0, 13);
    }
    return $u;
}

/**
 * Get the site-wide salt. It should be something hard for a hacker to get, so we depend on data gathered both from the database and file-system.
 *
 * @return ID_TEXT The salt
 */
function get_site_salt()
{
    $site_salt = get_value('site_salt');
    if ($site_salt === null) {
        $site_salt = produce_salt();
        set_value('site_salt', $site_salt);
    }
    return md5($site_salt);
}

/**
 * Get a randomised password.
 *
 * @return string The randomised password
 */
function get_rand_password()
{
    return produce_salt();
}

/**
 * Get a secure random number, the best this PHP version can do.
 *
 * @return integer The randomised number
 */
function get_secure_random_number()
{
    // 2147483647 is from MySQL limit http://dev.mysql.com/doc/refman/5.0/en/integer-types.html ; PHP_INT_MAX is higher on 64bit machines
    if (function_exists('random_bytes')) {
        $code = random_int(0, PHP_INT_MAX);
    } elseif ((function_exists('openssl_random_pseudo_bytes')) && (get_value('disable_openssl') !== '1')) {
        $code = intval(2147483647 * (hexdec(bin2hex(openssl_random_pseudo_bytes(4))) / 0xffffffff));
        if ($code < 0) {
            $code = -$code;
        }
    } elseif (function_exists('password_hash')) { // password_hash will include a randomised component
        $hash = password_hash(uniqid('', true), PASSWORD_BCRYPT, array('cost' => intval(get_option('crypt_ratchet'))));
        return crc32($hash);
    } else {
        $code = mt_rand(0, min(2147483647, mt_getrandmax()));
    }
    return $code;
}

/**
 * Check the given master password is valid.
 *
 * @param  SHORT_TEXT $password_given Given master password
 * @return boolean Whether it is valid
 */
function check_master_password($password_given)
{
    if (isset($GLOBALS['SITE_INFO']['admin_password'])) { // LEGACY
        $GLOBALS['SITE_INFO']['master_password'] = $GLOBALS['SITE_INFO']['admin_password'];
        unset($GLOBALS['SITE_INFO']['admin_password']);
    }

    global $SITE_INFO;
    if (!array_key_exists('master_password', $SITE_INFO)) {
        exit('No master password defined in _config.php currently so cannot authenticate');
    }
    $actual_password_hashed = $SITE_INFO['master_password'];
    if (strpos($actual_password_hashed, '$') !== false) {
        return password_verify($password_given, $actual_password_hashed);
    }

    // LEGACY
    $salt = '';
    if ((substr($actual_password_hashed, 0, 1) == '!') && (strlen($actual_password_hashed) == 33)) {
        $actual_password_hashed = substr($actual_password_hashed, 1);
        $salt = 'cms';

        // LEGACY
        if ($actual_password_hashed != md5($password_given . $salt)) {
            $salt = 'ocp';
        }
    }
    return (((strlen($password_given) != 32) && (hash_equals($actual_password_hashed, $password_given))) || (hash_equals($actual_password_hashed, md5($password_given . $salt))));
}
