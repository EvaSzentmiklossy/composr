<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2016

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__mail()
{
    require_lang('mail');

    global $SENDING_MAIL, $EMAIL_ATTACHMENTS, $LAST_MIME_MAIL_SENT;
    $SENDING_MAIL = false;
    $EMAIL_ATTACHMENTS = array();
    $LAST_MIME_MAIL_SENT = null;
}

/*
What headers to use can easily confuse. Here is a guide...

return-path    (aka envelope-from aka reverse-path)      SET BY SMTP SERVER, NOT HEADER
from           Who actually sent, SMTP-wise (should be accurate, as may be checked by SPF)
reply-to       Who replies go to
sender         Not needed, not often used
x-sender       As per sender, but might not be an email address

Full details:
http://people.dsv.su.se/~jpalme/ietf/ietf-mail-attributes.html
*/

/**
 * Attempt to send an e-mail to the specified recipient. The mail will be forwarding to the CC address specified in the options (if there is one, and if not specified not to cc).
 * The mail will be sent in dual HTML/text format, where the text is the unconverted Comcode source: if a member does not read HTML mail, they may wish to fallback to reading that.
 *
 * @param  string $subject_line The subject of the mail in plain text
 * @param  LONG_TEXT $message_raw The message, as Comcode
 * @param  ?array $to_email The destination (recipient) e-mail addresses [array of strings] (null: site staff address)
 * @param  ?mixed $to_name The recipient name. Array or string. (null: site name)
 * @param  EMAIL $from_email The from address (blank: site staff address)
 * @param  string $from_name The from name (blank: site name)
 * @param  ?array $advanced_parameters A map of additional parameters. See comments within this function implementation to know what can be sent. (null: none)
 * @return ?Tempcode A full page (not complete XHTML) piece of Tempcode to output (null: it worked so no Tempcode message)
 */
function dispatch_mail($subject_line, $message_raw, $to_email = null, $to_name = null, $from_email = '', $from_name = '', $advanced_parameters = null)
{
    $priority = isset($advanced_parameters['priority']) ? $advanced_parameters['priority'] : 3; // The message priority (1=urgent, 3=normal, 5=low)
    $attachments = isset($advanced_parameters['attachments']) ? $advanced_parameters['attachments'] : null; // An list of attachments (each attachment being a map, path=>filename) (null: none)
    $no_cc = isset($advanced_parameters['no_cc']) ? $advanced_parameters['no_cc'] : false; // Whether to CC to the CC address
    $as = isset($advanced_parameters['as']) ? $advanced_parameters['as'] : null; // Convert Comcode->tempcode as this member (a privilege thing: we don't want people being able to use admin rights by default!) (null: guest)
    $as_admin = isset($advanced_parameters['as_admin']) ? $advanced_parameters['as_admin'] : false; // Replace above with arbitrary admin
    $in_html = isset($advanced_parameters['in_html']) ? $advanced_parameters['in_html'] : false; // HTML-only
    $bypass_queue = isset($advanced_parameters['bypass_queue']) ? $advanced_parameters['bypass_queue'] : null; // Whether to bypass queueing
    $coming_out_of_queue = isset($advanced_parameters['coming_out_of_queue']) ? $advanced_parameters['coming_out_of_queue'] : false; // Whether to bypass queueing, because this code is running as a part of the queue management tools (null: auto-decide)
    $mail_template = isset($advanced_parameters['mail_template']) ? $advanced_parameters['mail_template'] : 'MAIL'; // The template used to show the email
    $extra_cc_addresses = isset($advanced_parameters['extra_cc_addresses']) ? $advanced_parameters['extra_cc_addresses'] : null; // Extra CC addresses to use (null: none)
    $extra_bcc_addresses = isset($advanced_parameters['extra_bcc_addresses']) ? $advanced_parameters['extra_bcc_addresses'] : null; // Extra BCC addresses to use (null: none)
    $require_recipient_valid_since = isset($advanced_parameters['require_recipient_valid_since']) ? $advanced_parameters['require_recipient_valid_since'] : null; // Implement the Require-Recipient-Valid-Since header (null: no restriction)
    $smtp_sockets_use = isset($advanced_parameters['smtp_sockets_use']) ? $advanced_parameters['smtp_sockets_use'] : null; // Whether to use SMTP sockets (null: default configured)
    $smtp_sockets_host = isset($advanced_parameters['smtp_sockets_host']) ? $advanced_parameters['smtp_sockets_host'] : null; // SMTP hostname (null: default configured)
    $smtp_sockets_port = isset($advanced_parameters['smtp_sockets_port']) ? $advanced_parameters['smtp_sockets_port'] : null; // SMTP port (null: default configured)
    $smtp_sockets_username = isset($advanced_parameters['smtp_sockets_username']) ? $advanced_parameters['smtp_sockets_username'] : null; // SMTP username (null: default configured)
    $smtp_sockets_password = isset($advanced_parameters['smtp_sockets_password']) ? $advanced_parameters['smtp_sockets_password'] : null; // SMTP password (null: default configured)
    $smtp_from_address = isset($advanced_parameters['smtp_from_address']) ? $advanced_parameters['smtp_from_address'] : null; // SMTP from address (null: default configured)
    $enveloper_override = isset($advanced_parameters['enveloper_override']) ? $advanced_parameters['enveloper_override'] : null; // Use envelope override option for sendmail (null: default configured)
    $allow_ext_images = isset($advanced_parameters['allow_ext_images']) ? $advanced_parameters['allow_ext_images'] : null; // Allow external image references rather than embedding images (null: default configured)
    $website_email = isset($advanced_parameters['website_email']) ? $advanced_parameters['website_email'] : null; // Website e-mail address (null: default configured)

    if (is_null($smtp_sockets_use)) {
        $smtp_sockets_use = (get_option('smtp_sockets_use') == '1');
    }
    if (is_null($smtp_sockets_host)) {
        $smtp_sockets_host = get_option('smtp_sockets_host');
    }
    if (is_null($smtp_sockets_port)) {
        $smtp_sockets_port = intval(get_option('smtp_sockets_port'));
    }
    if (is_null($smtp_sockets_username)) {
        $smtp_sockets_username = get_option('smtp_sockets_username');
    }
    if (is_null($smtp_sockets_password)) {
        $smtp_sockets_password = get_option('smtp_sockets_password');
    }
    if (is_null($smtp_from_address)) {
        $smtp_from_address = get_option('smtp_from_address');
    }
    if (is_null($enveloper_override)) {
        $enveloper_override = (get_option('enveloper_override') == '1');
    }
    if (is_null($allow_ext_images)) {
        $allow_ext_images = (get_option('allow_ext_images') == '1');
    }
    if (is_null($website_email)) {
        $website_email = get_option('website_email');
    }

    if (running_script('stress_test_loader')) {
        return null;
    }

    if (@$GLOBALS['SITE_INFO']['no_email_output'] === '1') {
        return null;
    }

    if (is_null($bypass_queue)) {
        $bypass_queue = (($priority < 3) || (strpos(serialize($attachments), 'tmpfile') !== false));
    }

    global $EMAIL_ATTACHMENTS;
    $EMAIL_ATTACHMENTS = array();

    require_code('site');
    require_code('mime_types');

    if (is_null($as)) {
        $as = $GLOBALS['FORUM_DRIVER']->get_guest_id();
    }

    if (count($attachments) == 0) {
        $attachments = null;
    }
    if (is_null($extra_cc_addresses)) {
        $extra_cc_addresses = array();
    }
    if (is_null($extra_bcc_addresses)) {
        $extra_bcc_addresses = array();
    }

    if (!$coming_out_of_queue) {
        if ((mt_rand(0, 100) == 1) && (!$GLOBALS['SITE_DB']->table_is_locked('logged_mail_messages'))) {
            $GLOBALS['SITE_DB']->query('DELETE FROM ' . get_table_prefix() . 'logged_mail_messages WHERE m_date_and_time<' . strval(time() - 60 * 60 * 24 * 14) . ' AND m_queued=0'); // Log it all for 2 weeks, then delete
        }

        $through_queue = (!$bypass_queue) && (((cron_installed()) && (get_option('mail_queue') === '1')) || (get_option('mail_queue_debug') === '1'));
        if (!is_null($attachments)) {
            foreach (array_keys($attachments) as $path) {
                if ((substr($path, 0, strlen(get_custom_file_base() . '/')) != get_custom_file_base() . '/') && (substr($path, 0, strlen(get_file_base() . '/')) != get_file_base() . '/')) {
                    $through_queue = false;
                }
            }
        }

        if (!$in_html) {
            inject_web_resources_context_to_comcode($message_raw);
        }

        $GLOBALS['SITE_DB']->query_insert('logged_mail_messages', array(
            'm_subject' => cms_mb_substr($subject_line, 0, 255),
            'm_message' => $message_raw,
            'm_to_email' => serialize($to_email),
            'm_to_name' => serialize($to_name),
            'm_extra_cc_addresses' => serialize($extra_cc_addresses),
            'm_extra_bcc_addresses' => serialize($extra_bcc_addresses),
            'm_join_time' => $require_recipient_valid_since,
            'm_from_email' => $from_email,
            'm_from_name' => $from_name,
            'm_priority' => $priority,
            'm_attachments' => serialize($attachments),
            'm_no_cc' => $no_cc ? 1 : 0,
            'm_as' => $as,
            'm_as_admin' => $as_admin ? 1 : 0,
            'm_in_html' => $in_html ? 1 : 0,
            'm_date_and_time' => time(),
            'm_member_id' => get_member(),
            'm_url' => get_self_url(true),
            'm_queued' => $through_queue ? 1 : 0,
            'm_template' => $mail_template,
        ), false, !$through_queue); // No errors if we don't NEED this to work

        if ($through_queue) {
            return null;
        }
    }

    global $SENDING_MAIL;
    if ($SENDING_MAIL) {
        return null;
    }
    $SENDING_MAIL = true;

    // To and from, and language
    $staff_address = get_option('staff_address');
    if (is_null($to_email)) {
        $to_email = array($staff_address);
    }
    $to_email_new = array();
    foreach ($to_email as $test_address) {
        if ($test_address != '') {
            $to_email_new[] = $test_address;
        }
    }
    $to_email = $to_email_new;
    if ($to_email == array()) {
        $SENDING_MAIL = false;
        return null;
    }
    if ($to_email[0] == $staff_address) {
        $lang = get_site_default_lang();
    } else {
        $lang = user_lang();
        if (method_exists($GLOBALS['FORUM_DRIVER'], 'get_member_from_email_address')) {
            $member_id = $GLOBALS['FORUM_DRIVER']->get_member_from_email_address($to_email[0]);
            if (!is_null($member_id)) {
                $lang = get_lang($member_id);
            }
        }
    }
    if (is_null($to_name)) {
        if ($to_email[0] == $staff_address) {
            $to_name = get_site_name();
        } else {
            $to_name = '';
        }
    }
    if ($from_email == '') {
        $from_email = get_option('staff_address');
    }
    if ($from_name == '') {
        $from_name = get_site_name();
    }
    $from_email = str_replace(array("\r", "\n"), array('', ''), $from_email);
    $from_name = str_replace(array("\r", "\n"), array('', ''), $from_name);

    if (!$coming_out_of_queue) {
        cms_profile_start_for('dispatch_mail');
    }

    $theme = method_exists($GLOBALS['FORUM_DRIVER'], 'get_theme') ? $GLOBALS['FORUM_DRIVER']->get_theme() : 'default';
    if ($theme == 'default') { // Sucks, probably due to sending from Admin Zone...
        $theme = $GLOBALS['FORUM_DRIVER']->get_theme(''); // ... So get theme of welcome zone
    }

    // Line termination is fiddly. It is safer to rely on sendmail supporting \n than undetectable-qmail/postfix-masquerading-as-sendmail not supporting the correct \r\n
    /*
    $sendmail_path = ini_get('sendmail_path');
    if ((strpos($sendmail_path, 'qmail') !== false) || (strpos($sendmail_path, 'sendmail') !== false)) {
        $line_term = "\n";
    } else {
        $line_term = "\r\n";
    }
    */
    if ((strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') || ($smtp_sockets_use)) {
        $line_term = "\r\n";
    /*} elseif (strtoupper(substr(PHP_OS, 0, 3)) == 'MAC')
    {
        $line_term = "\r";*/
    } else {
        $line_term = "\n";
    }

    // We use the boundary to seperate message parts
    $_boundary = uniqid('Composr', true);
    $boundary = $_boundary . '_1';
    $boundary2 = $_boundary . '_2';
    $boundary3 = $_boundary . '_3';

    // Our subject
    $subject = do_template('MAIL_SUBJECT', array('_GUID' => '44a57c666bb00f96723256e26aade9e5', 'SUBJECT_LINE' => $subject_line), $lang, false, null, '.txt', 'text', $theme);
    $tightened_subject = $subject->evaluate($lang);
    $tightened_subject = str_replace(array("\r", "\n"), array('', ''), $tightened_subject);

    $regexp = '#^[\x' . dechex(32) . '-\x' . dechex(126) . ']*$#';
    if (preg_match($regexp, $tightened_subject) == 0) {
        $tightened_subject = '=?' . do_lang('charset', null, null, null, $lang) . '?B?' . base64_encode($tightened_subject) . "?=";
    }
    if (preg_match($regexp, $from_name) == 0) {
        $from_name = '=?' . do_lang('charset', null, null, null, $lang) . '?B?' . base64_encode($from_name) . "?=";
    }
    if (is_array($to_name)) {
        foreach ($to_name as $i => $_to_name) {
            if (preg_match($regexp, $_to_name) == 0) {
                $to_name[$i] = '=?' . do_lang('charset', null, null, null, $lang) . '?B?' . base64_encode($_to_name) . "?=";
            }
        }
    } else {
        if (preg_match($regexp, $to_name) == 0) {
            $to_name = '=?' . do_lang('charset', null, null, null, $lang) . '?B?' . base64_encode($to_name) . "?=";
        }
    }

    $simplify_when_can = true; // Used for testing. Not actually needed

    global $CID_IMG_ATTACHMENT;
    $CID_IMG_ATTACHMENT = array();

    // Evaluate message. Needs doing early so we know if we have any headers
    if (!$in_html) {
        $cache_sig = serialize(array(
            $lang,
            $mail_template,
            $subject,
            $theme,
            crc32($message_raw),
        ));

        static $html_content_cache = array();
        if (isset($html_content_cache[$cache_sig])) {
            list($html_evaluated, $message_plain, $EMAIL_ATTACHMENTS) = $html_content_cache[$cache_sig];
        } else {
            require_code('media_renderer');
            push_media_mode(peek_media_mode() | MEDIA_LOWFI);

            push_lax_comcode(true);
            $html_content = comcode_to_tempcode($message_raw, $as, $as_admin);
            pop_lax_comcode();

            $message_html = null;
            $html_evaluated = null;
            $derive_css = true;
            $_html_content = $html_content->evaluate($lang);
            $_html_content = preg_replace('#(keep|for)_session=\w*#', 'filtered=1', $_html_content);
            $is_already_full_html = (stripos($_html_content, '<html') !== false);
            if ($is_already_full_html) {
                $html_evaluated = $_html_content;
                $derive_css = (strpos($_html_content, '{CSS') !== false);
            } else {
                $message_html = do_template($mail_template, array(
                    '_GUID' => 'b23069c20202aa59b7450ebf8d49cde1',
                    'CSS' => '{CSS}',
                    'LOGOURL' => get_logo_url(''),
                    'LANG' => $lang,
                    'TITLE' => $subject,
                    'CONTENT' => $_html_content,
                ), $lang, false, null, '.tpl', 'templates', $theme);
            }
            if ($derive_css) {
                require_css('email');
                $css = css_tempcode(true, false, ($message_html === null) ? null : $message_html->evaluate($lang), $theme);
                $_css = $css->evaluate($lang);
                if (!GOOGLE_APPENGINE) {
                    if (!$allow_ext_images) {
                        $_css = preg_replace_callback('#url\(["\']?(http://[^"]*)["\']?\)#U', '_mail_css_rep_callback', $_css);
                    }
                }
                if ($message_html !== null) {
                    $message_html->singular_bind('CSS', $_css);
                    $html_evaluated = $message_html->evaluate($lang);
                }
            }

            // Cleanup the Comcode a bit
            $message_plain = strip_comcode($message_raw);

            $html_content_cache[$cache_sig] = array($html_evaluated, $message_plain, $EMAIL_ATTACHMENTS);

            pop_media_mode();
        }
        $attachments = array_merge(is_null($attachments) ? array() : $attachments, $EMAIL_ATTACHMENTS);
    } else {
        $html_evaluated = $message_raw;
    }

    // Headers
    $headers = '';
    if ($website_email != '') {
        if (get_option('use_true_from') == '0') {
            $headers .= 'From: "' . $from_name . '" <' . $website_email . '>' . $line_term;
        } else {
            $headers .= 'From: "' . $from_name . '" <' . $from_email . '>' . $line_term;
        }
        $headers .= 'Return-Path: <' . $website_email . '>' . $line_term;
        $headers .= 'X-Sender: <' . $website_email . '>' . $line_term;
    } // else maybe server won't let us set it due to whitelist security, and we must let it use it's default (i.e. accountname@hostname)
    $headers .= 'Reply-To: <' . $from_email . '>' . $line_term;
    $cc_address = $no_cc ? '' : get_option('cc_address');
    if ($cc_address != '') {
        if (get_option('bcc') == '0') {
            $extra_cc_addresses[] = $cc_address;
        } else {
            $extra_bcc_addresses[] = $cc_address;
        }
    }
    if ($extra_cc_addresses !== array()) {
        $headers .= 'Cc: ';
        foreach ($extra_cc_addresses as $i => $extra_cc_address) {
            if ($i != 0) {
                $headers .= ', ';
            }
            $headers .= '<' . $extra_cc_address . '>';
        }
        $headers .= $line_term;
    }
    if ($extra_bcc_addresses !== array()) {
        $headers .= 'Bcc: ';
        foreach ($extra_bcc_addresses as $i => $extra_bcc_address) {
            if ($i != 0) {
                $headers .= ', ';
            }
            $headers .= '<' . $extra_bcc_address . '>';
        }
        $headers .= $line_term;
    }
    $headers .= 'Date: ' . date('r', time()) . $line_term;
    $headers .= 'Message-ID: <' . $_boundary . '@' . get_domain() . '>' . $line_term;
    $headers .= 'X-Priority: ' . strval($priority) . $line_term;
    $brand_name = get_value('rebrand_name');
    if (is_null($brand_name)) {
        $brand_name = 'Composr';
    }
    $headers .= 'X-Mailer: ' . $brand_name . $line_term;
    if ((count($to_email) == 1) && (!is_null($require_recipient_valid_since))) {
        $_require_recipient_valid_since = date('r', $require_recipient_valid_since);
        $headers .= 'Require-Recipient-Valid-Since: ' . $to_email[0] . '; ' . $_require_recipient_valid_since . $line_term;
    }
    $headers .= 'MIME-Version: 1.0' . $line_term;
    if ((!is_null($attachments)) || (!$simplify_when_can)) {
        $headers .= 'Content-Type: multipart/mixed; boundary="' . $boundary . '"';
    } else {
        $headers .= 'Content-Type: multipart/alternative; boundary="' . $boundary2 . '"';
    }
    $sending_message = '';
    $sending_message .= 'This is a multi-part message in MIME format.' . $line_term . $line_term;
    if ((!is_null($attachments)) || (!$simplify_when_can)) {
        $sending_message .= '--' . $boundary . $line_term;
        $sending_message .= 'Content-Type: multipart/alternative; boundary="' . $boundary2 . '"' . $line_term . $line_term . $line_term;
    }

    if (GOOGLE_APPENGINE) {
        require_once('google/appengine/api/mail/Message.php');
        $message_class = 'google\appengine\api\mail\Message';

        $reply_to = $from_email;//$from_name.' <'.$from_email.'>'; GAE doesn't support nice format yet

        $mail_options = array(
            'sender' => $website_email,
            'subject' => $subject->evaluate($lang),
            'textBody' => $message_plain,
            'htmlBody' => $html_evaluated,
        );

        try {
            $message = new $message_class($mail_options);
            $message->addCc($extra_cc_addresses);
            $message->addBcc($extra_bcc_addresses);
            $message->setReplyTo($reply_to);
            foreach ($to_email as $_to_email) {
                $message->addTo($_to_email); // $to_name.' <'.$_to_email.'>' GAE doesn't support nice format yet
            }
            foreach ($attachments as $path => $filename) {
                if ((strpos($path, '://') === false) && (substr($path, 0, 5) != 'gs://')) {
                    if (!is_file($path)) {
                        continue;
                    }
                    $contents = file_get_contents($path);
                } else {
                    $contents = http_download_file($path, null, false);
                    if (is_null($contents)) {
                        continue;
                    }
                }
                $message->addAttachment($filename, $contents);
            }
            $message->send();
        } catch (InvalidArgumentException $e) {
            $error = $e->getMessage();

            require_code('site');
            attach_message(!is_null($error) ? make_string_tempcode($error) : do_lang_tempcode('MAIL_FAIL', escape_html(get_option('staff_address'))), 'warn', false, true);
        }

        $SENDING_MAIL = false;
        return null;
    }

    $base64_encode = (get_value('base64_emails') === '1'); // More robust, but more likely to be spam-blocked, and some servers can scramble it.

    // Plain version
    if (!$in_html) {
        $sending_message .= '--' . $boundary2 . $line_term;
        $sending_message .= 'Content-Type: text/plain; charset=' . ((preg_match($regexp, $message_plain) == 0) ? do_lang('charset', null, null, null, $lang) : 'us-ascii') . $line_term; // '; name="message.txt"'.  Outlook doesn't like: makes it think it's an attachment
        if ($base64_encode) {
            $sending_message .= 'Content-Transfer-Encoding: base64' . $line_term . $line_term;
            $sending_message .= chunk_split(base64_encode(unixify_line_format($message_plain)) . $line_term, 76, $line_term);
        } else {
            $sending_message .= 'Content-Transfer-Encoding: 8bit' . $line_term . $line_term;
            $sending_message .= wordwrap(str_replace("\n", $line_term, unixify_line_format($message_plain)) . $line_term, 988, $line_term, true);
        }
    }

    // HTML version
    $sending_message .= '--' . $boundary2 . $line_term;
    $sending_message .= 'Content-Type: multipart/related; type="text/html"; boundary="' . $boundary3 . '"' . $line_term . $line_term . $line_term;
    $sending_message .= '--' . $boundary3 . $line_term;
    $sending_message .= 'Content-Type: text/html; charset=' . ((preg_match($regexp, $html_evaluated) == 0) ? do_lang('charset', null, null, null, $lang) : 'us-ascii') . $line_term; // .'; name="message.html"'. Outlook doesn't like: makes it think it's an attachment
    if (!$allow_ext_images) {
        $cid_before = array_keys($CID_IMG_ATTACHMENT);
        $html_evaluated = preg_replace_callback('#<img\s([^>]*)src="(http://[^"]*)"#U', '_mail_img_rep_callback', $html_evaluated);
        $cid_just_html = array_diff(array_keys($CID_IMG_ATTACHMENT), $cid_before);
        $matches = array();
        foreach (array('#<([^"<>]*\s)style="([^"]*)"#', '#<style( [^<>]*)?' . '>(.*)</style>#Us') as $over) {
            $num_matches = preg_match_all($over, $html_evaluated, $matches);
            for ($i = 0; $i < $num_matches; $i++) {
                $altered_inner = preg_replace_callback('#url\(["\']?(http://[^"]*)["\']?\)#U', '_mail_css_rep_callback', $matches[2][$i]);
                if ($matches[2][$i] != $altered_inner) {
                    $altered_outer = str_replace($matches[2][$i], $altered_inner, $matches[0][$i]);
                    $html_evaluated = str_replace($matches[0][$i], $altered_outer, $html_evaluated);
                }
            }
        }

        // This is a hack to stop the images used by CSS showing as attachments in some mail clients
        $cid_just_css = array_diff(array_keys($CID_IMG_ATTACHMENT), $cid_just_html);
        foreach ($cid_just_css as $cid) {
            $html_evaluated .= '<img width="0" height="0" src="cid:' . $cid . '" />';
        }
    }

    if ($base64_encode) {
        $sending_message .= 'Content-Transfer-Encoding: base64' . $line_term . $line_term;
        $sending_message .= chunk_split(base64_encode(unixify_line_format($html_evaluated)) . $line_term, 76, $line_term);
    } else {
        $sending_message .= 'Content-Transfer-Encoding: 8bit' . $line_term . $line_term; // Requires RFC 1652
        $sending_message .= wordwrap(str_replace("\n", $line_term, unixify_line_format($html_evaluated)) . $line_term, 988, $line_term, true);
    }
    $total_filesize = 0;
    foreach ($CID_IMG_ATTACHMENT as $id => $img) {
        $test = _get_image_for_cid($img, $as, $total_filesize);
        if (is_null($test)) {
            continue;
        }
        list($mime_type, $filename, $file_contents) = $test;

        $sending_message .= '--' . $boundary3 . $line_term;
        $sending_message .= 'Content-Type: ' . str_replace("\r", '', str_replace("\n", '', $mime_type)) . $line_term;
        $sending_message .= 'Content-ID: <' . $id . '>' . $line_term;
        $sending_message .= 'Content-Disposition: inline; filename="' . str_replace("\r", '', str_replace("\n", '', $filename)) . '"' . $line_term;
        $sending_message .= 'Content-Transfer-Encoding: base64' . $line_term . $line_term;
        if (is_string($file_contents)) {
            $sending_message .= chunk_split(base64_encode($file_contents), 76, $line_term);
        }
    }
    $sending_message .= $line_term . '--' . $boundary3 . '--' . $line_term . $line_term;

    $sending_message .= $line_term . '--' . $boundary2 . '--' . $line_term . $line_term;

    // Attachments
    if (!is_null($attachments)) {
        foreach ($attachments as $path => $filename) {
            $sending_message .= '--' . $boundary . $line_term;
            $sending_message .= 'Content-Type: ' . get_mime_type(get_file_extension($filename), has_privilege($as, 'comcode_dangerous')) . $line_term; // . '; name="' . str_replace("\r", '', str_replace("\n", '', $filename)).'"'   http://www.imc.org/ietf-822/old-archive2/msg02121.html
            $sending_message .= 'Content-Transfer-Encoding: base64' . $line_term;
            $sending_message .= 'Content-Disposition: attachment; filename="' . str_replace("\r", '', str_replace("\n", '', $filename)) . '"' . $line_term . $line_term;

            if ((strpos($path, '://') === false) && (substr($path, 0, 5) != 'gs://')) {
                if (!is_file($path)) {
                    continue;
                }
                $contents = file_get_contents($path);
            } else {
                $contents = http_download_file($path, null, false);
                if (is_null($contents)) {
                    continue;
                }
            }
            $sending_message .= chunk_split(base64_encode($contents), 76, $line_term);
        }

        $sending_message .= $line_term . '--' . $boundary . '--' . $line_term;
    }

    $GLOBALS['LAST_MIME_MAIL_SENT'] = gather_full_mime_message($line_term, $to_name, $to_email, 0, $tightened_subject, $headers, $sending_message);

    // Support for SMTP sockets rather than PHP mail()
    $error = null;
    if (($smtp_sockets_use) && (php_function_allowed('fsockopen'))) {
        $worked = false;

        $host = $smtp_sockets_host;
        $port = $smtp_sockets_port;

        $errno = 0;
        $errstr = '';
        foreach ($to_email as $i => $to) {
            static $socket = null;
            if ($socket === null || $socket === false) {
                $socket = @fsockopen($host, $port, $errno, $errstr, 30.0);
                $new_connection = true;
            } else {
                $new_connection = false;
            }
            if ($socket !== false) {
                if ($new_connection) {
                    $base_url = parse_url(get_base_url());
                    $domain = $base_url['host'];

                    $rcv = fread($socket, 1024);

                    // Log in if necessary
                    $username = $smtp_sockets_username;
                    $password = $smtp_sockets_password;
                    if ($username != '') {
                        fwrite($socket, 'EHLO ' . $domain . "\r\n");
                        $rcv = fread($socket, 1024);

                        fwrite($socket, "AUTH LOGIN\r\n");
                        $rcv = fread($socket, 1024);
                        if (strtolower(substr($rcv, 0, 3)) == '334') {
                            fwrite($socket, base64_encode($username) . "\r\n");
                            $rcv = fread($socket, 1024);
                            if ((strtolower(substr($rcv, 0, 3)) == '235') || (strtolower(substr($rcv, 0, 3)) == '334')) {
                                fwrite($socket, base64_encode($password) . "\r\n");
                                $rcv = fread($socket, 1024);
                                if (strtolower(substr($rcv, 0, 3)) == '235') {
                                } else {
                                    $error = do_lang('MAIL_ERROR_CONNECT_PASSWORD') . ' (' . str_replace($password, '*', $rcv) . ')';
                                }
                            } else {
                                $error = do_lang('MAIL_ERROR_CONNECT_USERNAME') . ' (' . $rcv . ')';
                            }
                        } else {
                            $error = do_lang('MAIL_ERROR_CONNECT_AUTH') . ' (' . $rcv . ')';
                        }
                    } else {
                        fwrite($socket, 'HELO ' . $domain . "\r\n");
                        $rcv = fread($socket, 1024);
                    }
                }

                if (is_null($error)) {
                    if ($smtp_from_address == '') {
                        $smtp_from_address = $website_email;
                    }
                    fwrite($socket, 'MAIL FROM:<' . $smtp_from_address . ">\r\n");
                    $rcv = fread($socket, 1024);
                    if ((strtolower(substr($rcv, 0, 3)) == '250') || (strtolower(substr($rcv, 0, 3)) == '251')) {
                        $sent_one = false;
                        fwrite($socket, "RCPT TO:<" . $to_email[$i] . ">\r\n");
                        $rcv = fread($socket, 1024);
                        if ((strtolower(substr($rcv, 0, 3)) != '250') && (strtolower(substr($rcv, 0, 3)) != '251')) {
                            $error = do_lang('MAIL_ERROR_TO') . ' (' . $rcv . ')' . ' ' . $to_email[$i];
                        } else {
                            $sent_one = true;
                        }
                        if ($sent_one) {
                            fwrite($socket, "DATA\r\n");
                            $rcv = fread($socket, 1024);
                            if (strtolower(substr($rcv, 0, 3)) == '354') {
                                fwrite($socket, preg_replace('#^\.#m', '..', gather_full_mime_message($line_term, $to_name, $to_email, $i, $tightened_subject, $headers, $sending_message)));
                                fwrite($socket, "\r\n.\r\n");
                                $rcv = fread($socket, 1024);
                                if (strtolower(substr($rcv, 0, 3)) != '250') {
                                    $error = do_lang('MAIL_ERROR_DATA') . ' (' . $rcv . ')';
                                }
                                fwrite($socket, "QUIT\r\n");
                                $rcv = fread($socket, 1024);
                            } else {
                                $error = do_lang('MAIL_ERROR_DATA') . ' (' . $rcv . ')';
                            }
                        }
                    } else {
                        $error = do_lang('MAIL_ERROR_FROM') . ' (' . $rcv . ')';
                    }

                    if (@fwrite($socket, "RSET\r\n") === false) { // Cut out. At least one server does this
                        @fclose($socket);
                        $socket = null;
                    } else {
                        $rcv = fread($socket, 1024);
                    }
                }

                if (!is_null($socket)) {
                    //fclose($socket);  Let it disconnect at script end or time-out
                }
                if (is_null($error)) {
                    $worked = true;
                }
            } else {
                $error = do_lang('MAIL_ERROR_CONNECT', $host, strval($port));
            }
        }
    } else {
        $worked = false;
        foreach ($to_email as $i => $to) {
            push_suppress_error_death(true);

            $additional = '';
            if ($enveloper_override && $website_email != '') {
                $additional = '-f ' . $website_email;
            }
            $_to_name = preg_replace('#@.*$#', '', is_array($to_name) ? $to_name[$i] : $to_name); // preg_replace is because some servers may reject sending names that look like e-mail addresses. Composr tries this from recommend module.
            if (($_to_name == '') || (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN')) {
                $to_line = $to;
            } else {
                $to_line = '"' . $_to_name . '" <' . $to . '>';
            }
            $php_errormsg = mixed();
            if (get_value('manualproc_mail') === '1') {
                require_code('mail2');
                manualproc_mail($to_line, $tightened_subject, $sending_message, $headers, $additional);
            } else {
                if ((str_replace(array('on', 'true', 'yes'), array('1', '1', '1'), strtolower(ini_get('safe_mode'))) == '1') || ($additional == '')) {
                    $worked = mail($to_line, $tightened_subject, $sending_message, $headers);
                } else {
                    $worked = mail($to_line, $tightened_subject, $sending_message, $headers, $additional);
                }
            }
            if ((!$worked) && (isset($php_errormsg))) {
                $error = $php_errormsg;
            }

            pop_suppress_error_death();
        }
    }

    if (!$coming_out_of_queue) {
        cms_profile_end_for('dispatch_mail', $subject_line);
    }

    if (!$worked) {
        require_code('site');
        attach_message(!is_null($error) ? make_string_tempcode($error) : do_lang_tempcode('MAIL_FAIL', escape_html(get_option('staff_address'))), 'warn', false, true);
    }

    $SENDING_MAIL = false;
    return null;
}

/**
 * Download a URL, for use as an inline mail image.
 *
 * @param  string $line_term Line separator
 * @param  mixed $to_name Recipient names (string or array)
 * @param  mixed $to_email Recipient e-mails (string or array)
 * @param  integer $i Position in recipients
 * @param  string $tightened_subject Subject
 * @param  string $headers Headers
 * @param  string $sending_message Message body
 * @return string The mime message
 */
function gather_full_mime_message($line_term, $to_name, $to_email, $i, $tightened_subject, $headers, $sending_message)
{
    $full_mime_message = '';

    $_to_name = preg_replace('#@.*$#', '', is_array($to_name) ? $to_name[$i] : $to_name); // preg_replace is because some servers may reject sending names that look like e-mail addresses. Composr tries this from recommend module.
    if (count($to_email) == 1) {
        if ($_to_name == '') {
            $full_mime_message .= 'To: ' . $to_email[$i] . $line_term;
        } else {
            $full_mime_message .= 'To: ' . $_to_name . ' <' . $to_email[$i] . '>' . $line_term;
        }
    } else {
        $full_mime_message .= 'To: ' . $_to_name . $line_term;
    }

    $full_mime_message .= 'Subject: ' . $tightened_subject . $line_term;

    $full_mime_message .= $headers;

    $full_mime_message .= $line_term . $sending_message;

	return $full_mime_message;
}

/**
 * Download a URL, for use as an inline mail image.
 *
 * @param  URLPATH $img URL
 * @param  ?MEMBER $as Convert Comcode->tempcode as this member (a privilege thing: we don't want people being able to use admin rights by default!) (null: guest)
 * @param  integer $total_filesize Reference to where total filesize is being held
 * @return ?array A tuple: Mime type filename, file contents (null: error)
 */
function _get_image_for_cid($img, $as, &$total_filesize)
{
    $file_path_stub = convert_url_to_path($img);
    $mime_type = get_mime_type(get_file_extension($img), has_privilege($as, 'comcode_dangerous'));
    $filename = basename($img);
    if (!is_null($file_path_stub)) {
        $total_filesize += @filesize($file_path_stub);
        if ($total_filesize > 1024 * 1024 * 5) {
            return null; // Too large to process into an email
        }

        $file_contents = @file_get_contents($file_path_stub);
    } else {
        $file_contents = mixed();
        $matches = array();
        require_code('attachments');
        if ((preg_match('#^' . preg_quote(find_script('attachment'), '#') . '\?id=(\d+)&amp;thumb=(0|1)#', $img, $matches) != 0) && (strpos($img, 'forum_db=1') === false)) {
            $rows = $GLOBALS['SITE_DB']->query_select('attachments', array('*'), array('id' => intval($matches[1])), 'ORDER BY a_add_time DESC');
            if ((array_key_exists(0, $rows)) && (has_attachment_access($as, intval($matches[1])))) {
                $myrow = $rows[0];

                if ($matches[2] == '1') {
                    $full = $myrow['a_thumb_url'];
                } else {
                    $full = $myrow['a_url'];
                }

                if (url_is_local($full)) {
                    $_full = get_custom_file_base() . '/' . rawurldecode($full);
                    if (file_exists($_full)) {
                        $filename = $myrow['a_original_filename'];
                        require_code('mime_types');
                        $total_filesize += @filesize($_full);
                        if ($total_filesize > 1024 * 1024 * 5) {
                            return null; // Too large to process into an email
                        }
                        $file_contents = file_get_contents($_full);
                        $mime_type = get_mime_type(get_file_extension($filename), has_privilege($as, 'comcode_dangerous'));
                    }
                }
            }
        }
        if ($file_contents === null) {
            $file_contents = http_download_file($img, 1024 * 1024 * 5, false);
            if (is_null($file_contents)) {
                return null;
            }
            $total_filesize += strlen($file_contents);
            if ($total_filesize > 1024 * 1024 * 5) {
                return null; // Too large to process into an email
            }
            if (!is_null($GLOBALS['HTTP_DOWNLOAD_MIME_TYPE'])) {
                $mime_type = $GLOBALS['HTTP_DOWNLOAD_MIME_TYPE'];
            }
            if (!is_null($GLOBALS['HTTP_FILENAME'])) {
                $filename = $GLOBALS['HTTP_FILENAME'];
            }
        }
    }

    return array($mime_type, $filename, $file_contents);
}

/**
 * Filter out any CSS selector blocks from the given CSS if they definitely do not affect the given (X)HTML.
 * While this is a clever algorithm, it isn't so clever as to actually try and match each selector against a DOM tree. If any segment of a compound selector matches, match is assumed.
 *
 * @param  ID_TEXT $c CSS file
 * @param  ?ID_TEXT $theme Theme (null: default)
 * @param  string $context (X) HTML context under which CSS is filtered
 * @return string Filtered CSS
 */
function filter_css($c, $theme, $context)
{
    if (is_null($theme)) {
        $theme = $GLOBALS['FORUM_DRIVER']->get_theme();
    }

    // Reduce input parameters to critical components, and cache on - saves a lot of time if multiple emails sent by script
    static $cache = array();
    $simple_sig = preg_replace('#\s+(?!class)(?!id)[\w\-]+="[^"<>]*"#', '', preg_replace('#[^<>]*(<[^<>]+>)[^<>]*#s', '${1}', $context));
    $simple_sig .= $c . $theme;
    if (isset($cache[$simple_sig])) {
        return $cache[$simple_sig];
    }

    $_css = do_template($c, null, user_lang(), false, null, '.css', 'css', $theme);
    $css = $_css->evaluate();

    // Find out all our IDs
    $ids = array();
    $matches = array();
    $count = preg_match_all('#\sid=["\']([^"\']*)["\']#', $context, $matches);
    for ($i = 0; $i < $count; $i++) {
        $ids[$matches[1][$i]] = true;
    }

    // Find out all our classes
    $classes = array();
    $count = preg_match_all('#\sclass=["\']([^"\']*)["\']#', $context, $matches);
    for ($i = 0; $i < $count; $i++) {
        if ($matches[1][$i] == '') {
            continue;
        }
        $classes = array_merge($classes, preg_split('#\s+#', $matches[1][$i], -1, PREG_SPLIT_NO_EMPTY));
    }
    $classes = array_flip($classes);

    // Find all our XHTML tags
    $tags = array();
    $count = preg_match_all('#<(\w+)([^\w])#', $context, $matches);
    for ($i = 0; $i < $count; $i++) {
        $tags[$matches[1][$i]] = true;
    }

    // Strip comments from CSS. This optimises, and also avoids us needing to do a sophisticated parse
    $css = preg_replace('#/\*.*\*/#Us', '', $css);

    // Strip all media rules, we don't support parsing it, and e-mails will not be that complex
    $middle_regexp = '[^\{\}]*' . '\{[^\{\}]*\}' . '[^\{\}]*';
    $css = preg_replace('#@media[^\{\}]*\{(' . $middle_regexp . ')*\}#s', '', $css);

    // Find and process each CSS selector block
    $stack = array();
    $css_new = '';
    $last_pos = 0;
    do {
        $pos1 = strpos($css, '{', $last_pos);
        $pos2 = strpos($css, '}', $last_pos);
        if (($pos1 === false) && ($pos2 === false)) {
            break;
        }

        if (($pos1 === false) || (($pos2 !== false) && ($pos2 < $pos1))) {
            if (count($stack) != 0) {
                $start = array_pop($stack);
                if (count($stack) == 0) { // We've finished a top-level section
                    $real_start = strrpos(substr($css, 0, $start), '}');
                    $real_start = ($real_start === false) ? 0 : ($real_start + 1);
                    $selectors = explode(',', trim(substr($css, $real_start, $start - $real_start)));
                    $applies = false;
                    foreach ($selectors as $selector) {
                        $selector = trim($selector);

                        if (strpos($selector, '::selection') !== false) {
                            continue;
                        }
                        if (strpos($selector, 'a[href^="mailto:"]') !== false) {
                            continue;
                        }
                        if (strpos($selector, 'a[target="_blank"]') !== false) {
                            continue;
                        }

                        $matches = array();

                        // ID selectors
                        $num_matches = preg_match_all('#\#(\w+)#', $selector, $matches);
                        for ($i = 0; $i < $num_matches; $i++) {
                            if (!isset($ids[$matches[1][$i]])) {
                                continue 2;
                            }
                        }

                        // Class name selectors
                        $num_matches = preg_match_all('#\.(\w+)#', $selector, $matches);
                        for ($i = 0; $i < $num_matches; $i++) {
                            if (!isset($classes[$matches[1][$i]])) {
                                continue 2;
                            }
                        }

                        // Tag selectors
                        $num_matches = preg_match_all('#(^|\s|>)(\w+)#', $selector, $matches);
                        for ($i = 0; $i < $num_matches; $i++) {
                            if (!isset($tags[$matches[2][$i]])) {
                                continue 2;
                            }
                        }

                        $applies = true;
                        break;
                    }
                    if ($applies) {
                        $css_new .= trim(substr($css, $real_start, $pos2 - $real_start + 1)) . "\n\n"; // Append section
                    }
                }
            } else {
                //return $css; // Parsing error, extra close
                // But actually it's best we let it continue on
            }
            $last_pos = $pos2 + 1;
        } else {
            array_push($stack, $pos1);
            $last_pos = $pos1 + 1;
        }
    } while (true);

    $cache[$simple_sig] = $css_new;

    return $css_new;
}

/**
 * Replace an HTML img tag such that it is cid'd. Callback for preg_replace_callback.
 *
 * @param  array $matches Matches
 * @return string Replacement
 *
 * @ignore
 */
function _mail_img_rep_callback($matches)
{
    if ((!url_is_local($matches[0])) && (substr($matches[2], 0, strlen(get_custom_base_url())) != get_custom_base_url()) && (substr($matches[2], 0, strlen(get_base_url())) != get_base_url())) {
        return $matches[0];
    }

    global $CID_IMG_ATTACHMENT;
    $cid = uniqid('', true) . '@' . str_replace(' ', '_', get_domain()); // str_replace is in case someone has put in the domain wrong
    $CID_IMG_ATTACHMENT[$cid] = $matches[2];
    return '<img ' . $matches[1] . 'src="cid:' . $cid . '"';
}

/**
 * Replace CSS image references such that it is cid'd. Callback for preg_replace_callback.
 *
 * @param  array $matches Matches
 * @return string Replacement
 *
 * @ignore
 */
function _mail_css_rep_callback($matches)
{
    $filename = basename($matches[1]);
    if (($filename != 'block_background.png') && ($filename != 'gradient.png') && ($filename != 'keyboard.png') && ($filename != 'email_link.png') && ($filename != 'external_link.png')) {
        /*global $CID_IMG_ATTACHMENT;   CSS CIDs do not work with Thunderbird, but data does
        $cid = uniqid('', true) . '@' . get_domain();
        $CID_IMG_ATTACHMENT[$cid] = $matches[1];
        return 'url(\'cid:' . $cid . '\')';*/

        $total_filesize = 0;
        $test = _get_image_for_cid($matches[1], $GLOBALS['FORUM_DRIVER']->get_guest_id(), $total_filesize);
        if (is_null($test) || $total_filesize > 1024 * 50/*Let's be reasonable here*/) {
            return 'none';
        }
        list($mime_type, $filename, $file_contents) = $test;

        $value = 'data:' . get_mime_type(get_file_extension($filename), false) . ';base64,' . base64_encode($file_contents);
        return 'url(\'data:' . $value . '\')';
    }
    return 'none';
}
