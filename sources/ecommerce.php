<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2016

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    ecommerce
 */

/*
See codebook_1b for a technical overview. Follows are some notes.


systems/ecommerce hooks are structured like this...

config                                      (optional, for hooks with configurable products within admin_ecommerce module)
save_config                                 (optional, for hooks with configurable products within admin_ecommerce module)
get_product_category                        (optional, used if multiple products are in the hook and they want grouping on the purchasing wizard)
get_products                                (required)
is_available                                (optional but advisable)
get_available_quantity                      (only for cart items)
get_message                                 (optional but advisable)
get_product_details_for_cart                (only for cart items)
add_to_cart                                 (only for cart items)
show_cart_entry                             (only for cart items)
calculate_tax                               (only for cart items)
calculate_shipping_cost                     (only for cart items)
get_catalogue_template_parameters           (only for catalogue items)
get_terms                                   (optional)
get_needed_fields                           (optional)
get_identifier_manual_field_inputter        (optional)
handle_needed_fields                        (optional)
actualiser                                  (required if automatic actualisation will be a feature)
reduce_stock                                (only for cart items)
member_for                                  (required if point payment is supported, except for invoices and subscriptions)
get_product_dispatch_type                   (only for cart items)

systems/payment_gateways hooks are structured like this...

get_config                                  (required)
get_transaction_fee                         (optional)
get_logos                                   (optional)
generate_trans_id                           (required)
make_transaction_button                     (required if it provides remote payment)
make_cart_transaction_button                (optional)
make_subscription_button                    (required if it provides remote payment)
make_cancel_button                          (optional)
handle_ipn_transaction                      (required if it provides remote payment)
create_selection_list_card_types            (optional, only for providing local payment but also optional then)
do_local_transaction                        (required if it provides local payment)
store_shipping_address                      (optional)
get_callback_url_message                    (optional)
auto_cancel                                 (required, but may just return false)


Notifications and e-mailing...

SITUATION                                                                           NOTIFICATION CODE
---------                                                                           -----------------
raw transaction gone through (to user)                                              framework: payment_received
raw transaction gone through (to staff)                                             framework: payment_received_staff
transaction gone through, stuff sent for individual hooks (to user or to staff)     per product hook: ecom_product_request_*, new_order, paid_subscription_messages, service_paid_for_staff, service_cancelled_staff
invoice created (to user)                                                           manual trigger: invoice
invoice created (to staff)                                                          (none, staff know they created it)
subscription cancel request, needs manual attention (to user)                       (none, user knows they just did this)
subscription cancel request, needs manual attention (to staff)                      manual trigger: subscription_cancelled_staff
order manually dispatched (to user)                                                 per product hook: ecom_product_?, order_dispatched
order manually dispatched (to staff)                                                (none, staff know they just did this)

As you can see we usually send based on manual triggers, or in individual product hooks.
We send generic messages about payments received to users and staff (as cover-all reassurance in case product hooks do not and to supplement what the payment gateway will send).
We don't send e-mails for pending transactions or reversed transactions, we leave that to the payment gateway.
We don't try and e-mail guest users. We assume the payment gateway sends them a sensible message, or guest purchasing is disabled (inline joining is supported), or manual e-mails are sent to the contact details gathered by the payment gateway.


Shipping addresses...

Shipping addresses are only gathered for cart purchases.
It is assumed shipping details for other products will not be required, or will be requested manually, or will be found out from member profile details.
*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__ecommerce()
{
    if (!defined('PRODUCT_PURCHASE')) {
        define('PRODUCT_PURCHASE', 0);
        define('PRODUCT_INVOICE', 1);
        define('PRODUCT_SUBSCRIPTION', 2);
        define('PRODUCT_OTHER', 3);
        define('PRODUCT_CATALOGUE', 4); // used only with the cart
        define('PRODUCT_ORDERS', 5);

        define('ECOMMERCE_PRODUCT_AVAILABLE', 0);
        define('ECOMMERCE_PRODUCT_NO_GUESTS', 1); // Only used if current user really is a Guest
        define('ECOMMERCE_PRODUCT_ALREADY_HAS', 2);
        define('ECOMMERCE_PRODUCT_DISABLED', 3);
        define('ECOMMERCE_PRODUCT_PROHIBITED', 4);
        define('ECOMMERCE_PRODUCT_OUT_OF_STOCK', 5);
        define('ECOMMERCE_PRODUCT_MISSING', 6);
        define('ECOMMERCE_PRODUCT_INTERNAL_ERROR', 7);
    }

    require_lang('ecommerce');
}

/**
 * Automatically calculates a half-price points-based discount for a product.
 *
 * @param array $details The product details.
 * @return array The amended product details.
 */
function automatic_discount_calculation($details)
{
    if ($details['discount_points__num_points'] !== null) {
        // Already has discount
        return $details;
    }

    if ($details['price'] === null) {
        // Only via money
        return $details;
    }

    if ($details['price_points'] === null) {
        // Only via points
        return $details;
    }

    $details['discount_points__num_points'] = intval(round(floatval($details['price_points']) / 2.0));
    $details['discount_points__price_reduction'] = float_to_raw_string(floatval($details['price']) / 2.0);

    return $details;
}

/**
 * Find the next step for the purchasing module.
 *
 * @param object $product_object The product object.
 * @param ID_TEXT $type_code The product type.
 * @param ID_TEXT $step_before The step prior to the next step.
 * @return ?ID_TEXT The next step (null: error).
 */
function get_next_purchase_step($product_object, $type_code, $step_before)
{
    $steps = get_product_purchase_steps($product_object, $type_code, false);
    foreach ($steps as $i => $step) {
        if ($step[1] == $step_before) {
            if (!isset($steps[$i + 1])) {
                return null;
            }

            return $steps[$i + 1][1];
        }
    }

    return null;
}

/**
 * Find the purchasing module breadcrumb steps for a product.
 *
 * @param object $product_object The product object.
 * @param ID_TEXT $type_code Type code for product.
 * @param boolean $consider_categories Whether to consider a category screen.
 * @return array A structure describing the steps.
 */
function get_product_purchase_steps($product_object, $type_code, $consider_categories)
{
    $steps = array();

    $more_params = '';
    foreach ($_GET as $key => $val) {
        if ((is_string($val)) && (!in_array($key, array('page', 'type', 'category', 'type_code', 'purchase_id', 'points', 'cancel', 'from', 'message')))) {
            $more_params .= ':' . $key . '=' . cms_url_encode($val);
        }
    }

    $steps[] = array('_SELF:_SELF:browse' . $more_params, 'browse', do_lang_tempcode('ECOM_PURCHASE_STAGE_browse'));

    if ($consider_categories) {
        if (method_exists($product_object, 'get_product_category')) {
            $product_category = $product_object->get_product_category();
            $steps[] = array('_SELF:_SELF:browse:category=' . preg_replace('#^Hook\_ecommerce\_#', '', get_class($product_object)) . ':' . $more_params, 'browse', $product_category['category_name']);
        }
    }

    $more_params .= ':type_code=' . cms_url_encode($type_code);

    $message = method_exists($product_object, 'get_message') ? $product_object->get_message($type_code) : null;
    $has_message = ($message !== null) && (!$message->is_empty());
    if (($has_message) && (get_param_integer('include_message', 0) == 0)) {
        $steps[] = array('_SELF:_SELF:message' . ':' . $more_params, 'message', do_lang_tempcode('ECOM_PURCHASE_STAGE_message'));
    }

    $terms = method_exists($product_object, 'get_terms') ? $product_object->get_terms($type_code) : '';
    $has_terms = ($terms != '');
    if ($has_terms) {
        $steps[] = array('_SELF:_SELF:terms' . ':' . $more_params, 'terms', do_lang_tempcode('ECOM_PURCHASE_STAGE_terms'));
    }

    if (method_exists($product_object, 'get_needed_fields')) {
        require_code('form_templates');
        list($fields) = $product_object->get_needed_fields($type_code);
        $has_details = ($fields !== null);
    } else {
        $has_details = false;
    }
    if ($has_details) {
        $steps[] = array('_SELF:_SELF:details' . ':' . $more_params, 'details', do_lang_tempcode('ECOM_PURCHASE_STAGE_details'));
    }

    $purchase_id = get_param_string('purchase_id', null);
    if ($purchase_id !== null) {
        $more_params .= ':purchase_id=' . cms_url_encode($purchase_id);
    }

    $steps[] = array('_SELF:_SELF:pay' . ':' . $more_params, 'pay', do_lang_tempcode('ECOM_PURCHASE_STAGE_pay'));

    $steps[] = array('_SELF:_SELF:finish' . ':' . $more_params, 'finish', do_lang_tempcode('ECOM_PURCHASE_STAGE_finish'));

    return $steps;
}

/**
 * Check whether the system is in test mode (normally, not).
 *
 * @return boolean The answer.
 */
function ecommerce_test_mode()
{
    if (($GLOBALS['DEV_MODE']) && (get_param_integer('keep_ecommerce_local_test', 0) == 1)) {
        return true;
    }
    return (get_option('ecommerce_test_mode') == '1');
}

/**
 * Get the symbol of the currency we're trading in.
 *
 * @param  ?ID_TEXT $currency The currency (null: configured).
 * @return ID_TEXT The currency symbol.
 */
function ecommerce_get_currency_symbol($currency = null)
{
    if ($currency === null) {
        $currency = get_option('currency');
    }
    require_code('currency');
    list($symbol,) = get_currency_symbol($currency);
    return $symbol;
}

/**
 * Find a transaction fee from a transaction amount. Regular fees aren't taken into account.
 *
 * @param  float $amount A transaction amount.
 * @param  ID_TEXT $payment_gateway The payment gateway the payment went via.
 * @return float The fee
 */
function get_transaction_fee($amount, $payment_gateway)
{
    if (get_option('transaction_flat_cost') . get_option('transaction_percentage_cost') != '') {
        $fee = 0.0;
        if (get_option('transaction_flat_cost') != '') {
            $fee += floatval(get_option('transaction_flat_cost'));
        }
        if (get_option('transaction_percentage_cost') != '') {
            $fee += floatval(get_option('transaction_percentage_cost')) / 100.0 * $amount;
        }
        return round($fee, 2);
    }

    if ($payment_gateway == '') {
        return 0.0;
    }
    if ($payment_gateway == 'manual') {
        return 0.0;
    }

    if ((file_exists(get_file_base() . '/sources/hooks/systems/payment_gateway/' . $payment_gateway . '.php')) || (file_exists(get_file_base() . '/sources_custom/hooks/systems/payment_gateway/' . $payment_gateway . '.php'))) {
        require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
        $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);
        if (method_exists($payment_gateway_object, 'get_transaction_fee')) {
            return $payment_gateway_object->get_transaction_fee($amount);
        }
    }

    return 0.0;
}

/**
 * Make a transaction (payment) button.
 *
 * @param  ID_TEXT $type_code The product codename.
 * @param  SHORT_TEXT $item_name The human-readable product title.
 * @param  ID_TEXT $purchase_id The purchase ID.
 * @param  float $price Transaction price in money.
 * @param  ID_TEXT $currency The currency to use.
 * @param  integer $price_points Transaction price in points.
 * @param  ?ID_TEXT $payment_gateway The payment gateway the payment will go via (null: autodetect).
 * @return Tempcode The button
 */
function make_transaction_button($type_code, $item_name, $purchase_id, $price, $currency, $price_points = 0, $payment_gateway = null)
{
    if ($payment_gateway === null) {
        $payment_gateway = get_option('payment_gateway');
    }
    require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
    $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);

    $trans_expecting_id = $payment_gateway_object->generate_trans_id();
    $GLOBALS['SITE_DB']->query_insert('ecom_trans_expecting', array(
        'id' => $trans_expecting_id,
        'e_type_code' => $type_code,
        'e_purchase_id' => $purchase_id,
        'e_item_name' => $item_name,
        'e_member_id' => get_member(),
        'e_price' => float_to_raw_string($price),
        'e_currency' => $currency,
        'e_price_points' => $price_points,
        'e_ip_address' => get_ip_address(),
        'e_session_id' => get_session_id(),
        'e_time' => time(),
        'e_length' => null,
        'e_length_units' => '',
        'e_memo' => post_param_string('memo', ''),
    ));

    return $payment_gateway_object->make_transaction_button($trans_expecting_id, $type_code, $item_name, $purchase_id, $price, $currency);
}

/**
 * Make a shopping cart payment button.
 *
 * @param  AUTO_LINK $order_id Order ID.
 * @param  ID_TEXT $currency The currency to use.
 * @param  integer $price_points Transaction price in points.
 * @return Tempcode The button
 */
function make_cart_payment_button($order_id, $currency, $price_points = 0)
{
    $_items = $GLOBALS['SITE_DB']->query_select('shopping_order_details', array('p_name', 'p_price', 'p_quantity'), array('order_id' => $order_id));
    $items = array();
    foreach ($_items as $item) {
        $items[] = array(
            'PRODUCT_NAME' => $item['p_name'],
            'PRICE' => float_to_raw_string($item['p_price']),
            'QUANTITY' => strval($item['p_quantity']),
        );
    }
    $price = $GLOBALS['SITE_DB']->query_select_value('shopping_order', 'tot_price', array('id' => $order_id));

    $payment_gateway = get_option('payment_gateway');
    require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
    $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);

    $type_code = 'CART_ORDER_' . strval($order_id);
    $item_name = do_lang('CART_ORDER', strval($order_id));

    if (!method_exists($payment_gateway_object, 'make_cart_transaction_button')) {
        return $payment_gateway_object->make_transaction_button($type_code, $item_name, strval($order_id), $price, $currency, $price_points);
    }

    $trans_expecting_id = $payment_gateway_object->generate_trans_id();
    $GLOBALS['SITE_DB']->query_insert('ecom_trans_expecting', array(
        'id' => $trans_expecting_id,
        'e_type_code' => $type_code,
        'e_purchase_id' => strval($order_id),
        'e_item_name' => $item_name,
        'e_member_id' => get_member(),
        'e_price' => float_to_raw_string($price),
        'e_currency' => $currency,
        'e_price_points' => $price_points,
        'e_ip_address' => get_ip_address(),
        'e_session_id' => get_session_id(),
        'e_time' => time(),
        'e_length' => null,
        'e_length_units' => '',
        'e_memo' => post_param_string('memo', ''),
    ));

    return $payment_gateway_object->make_cart_transaction_button($trans_expecting_id, $items, $currency, $order_id);
}

/**
 * Make a subscription (payment) button.
 *
 * @param  ID_TEXT $type_code The product codename.
 * @param  SHORT_TEXT $item_name The human-readable product title.
 * @param  ID_TEXT $purchase_id The purchase ID.
 * @param  float $price Transaction price in money.
 * @param  ID_TEXT $currency The currency to use.
 * @param  integer $price_points Transaction price in points (only for first transaction).
 * @param  integer $length The subscription length in the units.
 * @param  ID_TEXT $length_units The length units.
 * @set    d w m y
 * @param  ?ID_TEXT $payment_gateway The payment gateway the payment will go via (null: autodetect).
 * @return Tempcode The button
 */
function make_subscription_button($type_code, $item_name, $purchase_id, $price, $currency, $price_points = 0, $length, $length_units, $payment_gateway = null)
{
    if ($payment_gateway === null) {
        $payment_gateway = get_option('payment_gateway');
    }
    require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
    $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);

    $trans_expecting_id = $payment_gateway_object->generate_trans_id();
    $GLOBALS['SITE_DB']->query_insert('ecom_trans_expecting', array(
        'id' => $trans_expecting_id,
        'e_type_code' => $type_code,
        'e_purchase_id' => $purchase_id,
        'e_item_name' => $item_name,
        'e_member_id' => get_member(),
        'e_price' => float_to_raw_string($price),
        'e_currency' => $currency,
        'e_price_points' => $price_points,
        'e_ip_address' => get_ip_address(),
        'e_session_id' => get_session_id(),
        'e_time' => time(),
        'e_length' => $length,
        'e_length_units' => $length_units,
        'e_memo' => post_param_string('memo', ''),
    ));

    return $payment_gateway_object->make_subscription_button($trans_expecting_id, $type_code, $item_name, $purchase_id, $price, $currency, $length, $length_units);
}

/**
 * Make a subscription cancellation button.
 *
 * @param  AUTO_LINK $purchase_id The purchase ID.
 * @param  ID_TEXT $payment_gateway The payment gateway the payment will go via.
 * @return ?Tempcode The button (null: no special cancellation -- just delete the subscription row to stop Composr regularly re-charging)
 */
function make_cancel_button($purchase_id, $payment_gateway)
{
    if ($payment_gateway == '') {
        return null;
    }
    if ($payment_gateway == 'manual') {
        return null;
    }
    require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
    $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);
    if (!method_exists($payment_gateway_object, 'make_cancel_button')) {
        return null;
    }
    return $payment_gateway_object->make_cancel_button($purchase_id);
}

/**
 * Send an invoice notification to a member.
 *
 * @param  MEMBER $member_id The member to send to.
 * @param  AUTO_LINK $id The invoice ID.
 */
function send_invoice_notification($member_id, $id)
{
    // Send out notification
    require_code('notifications');
    $_url = build_url(array('page' => 'invoices', 'type' => 'browse'), get_module_zone('invoices'), null, false, false, true);
    $url = $_url->evaluate();
    $subject = do_lang('INVOICE_SUBJECT', strval($id), null, null, get_lang($member_id));
    $body = do_notification_lang('INVOICE_MESSAGE', $url, get_site_name(), null, get_lang($member_id));
    dispatch_notification('invoice', null, $subject, $body, array($member_id));
}

/**
 * Find all products, except ones from hooks that might have too many to list (so don't rely on this for important backend tasks).
 *
 * @return array A list of maps of product details. 'product_object' is added to each detail map.
 */
function find_all_products()
{
    $_hooks = find_all_hooks('systems', 'ecommerce');
    $products = array();
    foreach (array_keys($_hooks) as $hook) {
        require_code('hooks/systems/ecommerce/' . filter_naughty_harsh($hook));
        $product_object = object_factory('Hook_ecommerce_' . filter_naughty_harsh($hook), true);
        if ($product_object === null) {
            continue;
        }
        $_products = $product_object->get_products();
        foreach ($_products as $type_code => $details) {
            $details['product_object'] = $product_object;
            $products[$type_code] = $details;
        }
    }
    sort_maps_by($products, 'item_name');
    return $products;
}

/**
 * Find product info row and other details.
 *
 * @param  ID_TEXT $search The product codename/item name
 * @return array A triple: The product info row, the product codename, the product object (all will be null if not found).
 */
function find_product_details($search)
{
    static $cache = array();
    $sz = $search;
    if (isset($cache[$sz])) {
        return $cache[$sz];
    }

    static $hook_products_cache = array();

    $_hooks = find_all_hooks('systems', 'ecommerce');
    foreach (array_keys($_hooks) as $hook) {
        require_code('hooks/systems/ecommerce/' . filter_naughty_harsh($hook));
        $product_object = object_factory('Hook_ecommerce_' . filter_naughty_harsh($hook), true);
        if ($product_object === null) {
            continue;
        }

        if (isset($hook_products_cache[$hook])) {
            $_products = $hook_products_cache[$hook];
        } else {
            $_products = $product_object->get_products($search);
            $hook_products_cache[$hook] = $_products;
        }

        $type_code = mixed();
        foreach ($_products as $type_code => $details) {
            if (is_integer($type_code)) {
                $type_code = strval($type_code);
            }

            if ($type_code == $search) {
                $ret = array($details, $type_code, $product_object);
                $cache[$sz] = $ret;
                return $ret;
            }
        }
    }

    $ret = array(null, null, null);
    $cache[$sz] = $ret;
    return $ret;
}

/**
 * Find whether local payment will be performed.
 *
 * @return boolean Whether local payment will be performed.
 */
function perform_local_payment()
{
    if (($GLOBALS['DEV_MODE']) && (get_param_integer('keep_ecommerce_local_test', 0) == 1)) {
        require_code('config2');
        set_option('payment_gateway', 'authorize');
        return true;
    }

    $payment_gateway = get_option('payment_gateway');
    require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
    $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);
    return ((get_option('use_local_payment') == '1') && (method_exists($payment_gateway_object, 'do_local_transaction')));
}

/**
 * Get a form for transacting local payments.
 *
 * @param  ID_TEXT $type_code The product codename.
 * @param  SHORT_TEXT $item_name The item name
 * @param  ID_TEXT $purchase_id The purchase ID
 * @param  float $price Transaction price in money.
 * @param  ID_TEXT $currency The currency to use.
 * @param  integer $price_points Transaction price in points (only for first transaction).
 * @param  ?integer $length The length (null: not a subscription)
 * @param  ID_TEXT $length_units The length units
 * @param  ?ID_TEXT $payment_gateway The payment gateway the payment will go via (null: autodetect).
 * @param  boolean $needs_shipping_address Whether a shipping address is needed.
 * @return array A tuple: The form fields, Hidden fields, Confidence logos, Payment processor links
 */
function get_transaction_form_fields($type_code, $item_name, $purchase_id, $price, $currency, $price_points, $length, $length_units, $payment_gateway = null, $needs_shipping_address = false)
{
    if ((!tacit_https()) && (!ecommerce_test_mode())) {
        warn_exit(do_lang_tempcode('NO_SSL_SETUP'));
    }

    if ($payment_gateway === null) {
        $payment_gateway = get_option('payment_gateway');
    }

    require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
    $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);

    if (!method_exists($payment_gateway_object, 'do_local_transaction')) {
        warn_exit(do_lang_tempcode('LOCAL_PAYMENT_NOT_SUPPORTED', escape_html($payment_gateway)));
    }

    $trans_expecting_id = $payment_gateway_object->generate_trans_id(); // gateway-compatible, probably random, transaction ID

    $GLOBALS['SITE_DB']->query_insert('ecom_trans_expecting', array(
        'id' => $trans_expecting_id,
        'e_type_code' => $type_code,
        'e_purchase_id' => $purchase_id,
        'e_item_name' => $item_name,
        'e_price' => float_to_raw_string($price),
        'e_currency' => $currency,
        'e_price_points' => $price_points,
        'e_member_id' => get_member(),
        'e_ip_address' => get_ip_address(),
        'e_session_id' => get_session_id(),
        'e_time' => time(),
        'e_length' => $length,
        'e_length_units' => $length_units,
        'e_memo' => post_param_string('memo', ''),
    ));

    require_code('form_templates');
    require_code('locations');

    $fields = new Tempcode();

    // Card fields...

    $shipping_email = $GLOBALS['FORUM_DRIVER']->get_member_email_address(get_member());

    if (ecommerce_test_mode()) {
        $cardholder_name = $GLOBALS['FORUM_DRIVER']->get_username(get_member());
        $card_type = 'Visa';
        $card_number = 4444333322221111;
        $card_start_date_year = intval(date('Y', utctime_to_usertime(time() - 60 * 60 * 24 * 365)));
        $card_start_date_month = intval(date('m', utctime_to_usertime(time() - 60 * 60 * 24 * 365)));
        $card_expiry_date_year = intval(date('Y', utctime_to_usertime(time() + 60 * 60 * 24 * 365)));
        $card_expiry_date_month = intval(date('m', utctime_to_usertime(time() + 60 * 60 * 24 * 365)));
        $card_issue_number = 1;
        $card_cv2 = 123;

        $billing_street_address = '3 Example Road';
        $billing_city = 'Coolborough';
        $billing_county = 'West testsome';
        $billing_state = 'England';
        $billing_post_code = 'L3 3T';
        $billing_country = 'GB';

        $shipping_firstname = 'John';
        $shipping_lastname = 'Doe';
        $shipping_street_address = '3 Example Road';
        $shipping_city = 'Coolborough';
        $shipping_county = 'West testsome';
        $shipping_state = 'England';
        $shipping_post_code = 'L3 3T';
        $shipping_country = 'GB';
        if ($shipping_email == '') {
            $shipping_email = 'test@example.com';
        }
        $shipping_phone = '01234 56789';
    } else {
        $cardholder_name = get_cms_cpf('payment_cardholder_name');
        $card_type = get_cms_cpf('payment_card_type');
        $_card_number = get_cms_cpf('payment_card_number');
        $card_number = ($_card_number === null) ? null : intval($_card_number);
        list($card_start_date_year, $card_start_date_month) = explode('/', get_cms_cpf('payment_card_start_date'));
        list($card_expiry_date_year, $card_expiry_date_month) = explode('/', get_cms_cpf('payment_card_expiry_date'));
        $_card_issue_number = get_cms_cpf('payment_card_issue_number');
        $card_issue_number = ($_card_issue_number === null) ? null : intval($_card_issue_number);
        $card_cv2 = null;

        $billing_street_address = get_cms_cpf('billing_street_address');
        $billing_city = get_cms_cpf('billing_city');
        $billing_county = get_cms_cpf('billing_county');
        $billing_state = get_cms_cpf('billing_state');
        $billing_post_code = get_cms_cpf('billing_post_code');
        $billing_country = get_cms_cpf('billing_country');

        $shipping_firstname = get_cms_cpf('firstname');
        $shipping_lastname = get_cms_cpf('lastname');
        $shipping_street_address = get_cms_cpf('street_address');
        $shipping_city = get_cms_cpf('city');
        $shipping_county = get_cms_cpf('county');
        $shipping_state = get_cms_cpf('state');
        $shipping_post_code = get_cms_cpf('post_code');
        $shipping_country = get_cms_cpf('country');
        $shipping_email = $GLOBALS['FORUM_DRIVER']->get_member_email_address(get_member());
        $shipping_phone = get_cms_cpf('mobile_phone_number');
    }

    $fields->attach(do_template('FORM_SCREEN_FIELD_SPACER', array('TITLE' => do_lang_tempcode('PAYMENT_DETAILS'))));

    $fields->attach(form_input_line(do_lang_cpf('payment_cardholder_name'), do_lang_tempcode('DESCRIPTION_CARDHOLDER_NAME'), 'payment_cardholder_name', $cardholder_name, true));
    if (method_exists($payment_gateway_object, 'create_selection_list_card_types')) {
        $fields->attach(form_input_list(do_lang_cpf('payment_card_type'), '', 'payment_card_type', $payment_gateway_object->create_selection_list_card_types($card_type)));
    }
    $fields->attach(form_input_integer(do_lang_cpf('payment_card_number'), do_lang_tempcode('DESCRIPTION_CARD_NUMBER'), 'payment_card_number', $card_number, true, null, 16));
    $fields->attach(form_input_date_components(do_lang_cpf('payment_card_start_date'), do_lang_tempcode('DESCRIPTION_CARD_START_DATE'), 'payment_card_start_date', true, true, false, intval(date('Y')) - 16, intval(date('Y')), $card_start_date_year, $card_start_date_month, null, false));
    $fields->attach(form_input_date_components(do_lang_cpf('payment_card_expiry_date'), do_lang_tempcode('DESCRIPTION_CARD_EXPIRY_DATE'), 'payment_card_expiry_date', true, true, false, intval(date('Y')), intval(date('Y')) + 16, $card_expiry_date_year, $card_expiry_date_month, null, true));
    $fields->attach(form_input_integer(do_lang_cpf('payment_card_issue_number'), do_lang_tempcode('DESCRIPTION_CARD_ISSUE_NUMBER'), 'payment_card_issue_number', $card_issue_number, false));
    $fields->attach(form_input_integer(do_lang_tempcode('CARD_CV2'), do_lang_tempcode('DESCRIPTION_CARD_CV2'), 'payment_card_cv2', $card_cv2, true, null, 4));

    if ((!is_guest()) && (get_forum_type() == 'cns') && (get_option('store_credit_card_numbers') == '1')) {
        $fields->attach(form_input_tick(do_lang_tempcode('SAVE_TO_ACCOUNT'), '', 'payment_save_to_account', get_cms_cpf('payment_cardholder_name') == ''));
    }

    // Billing address fields...

    $fields->attach(get_address_fields('billing_', $billing_street_address, $billing_city, $billing_county, $billing_state, $billing_post_code, $billing_country));

    if ((!is_guest()) && (get_forum_type() == 'cns') && (get_option('store_credit_card_numbers') == '1')) {
        $fields->attach(form_input_tick(do_lang_tempcode('SAVE_TO_ACCOUNT'), '', 'billing_save_to_account', get_cms_cpf('billing_street_address') == ''));
    }

    // Shipping address fields...

    if ($needs_shipping_address) {
        $fields->attach(do_template('FORM_SCREEN_FIELD_SPACER', array('TITLE' => do_lang_tempcode('SHIPPING_ADDRESS'))));

        $fields->attach(form_input_line(do_lang_cpf('firstname'), '', 'shipping_firstname', $shipping_firstname, true));
        $fields->attach(form_input_line(do_lang_cpf('lastname'), '', 'shipping_lastname', $shipping_lastname, true));
        $fields->attach(get_address_fields('shipping_', $shipping_street_address, $shipping_city, $shipping_county, $shipping_state, $shipping_post_code, $shipping_country));
        $fields->attach(form_input_email(do_lang_tempcode('EMAIL_ADDRESS'), '', 'shipping_email', $shipping_email, true));
        $fields->attach(form_input_line(do_lang_tempcode('PHONE_NUMBER'), '', 'shipping_phone', $shipping_phone, true));

        if ((!is_guest()) && (get_forum_type() == 'cns') && (get_option('store_credit_card_numbers') == '1')) {
            $fields->attach(form_input_tick(do_lang_tempcode('SAVE_TO_ACCOUNT'), '', 'shipping_save_to_account', get_cms_cpf('firstname') == ''));
        }
    }

    // Store transaction ID in hidden field...

    $hidden = new Tempcode();
    $hidden->attach(form_input_hidden('trans_id', $trans_expecting_id));

    // ---

    $logos = method_exists($payment_gateway_object, 'get_logos') ? $payment_gateway_object->get_logos() : new Tempcode();
    $payment_processor_links = method_exists($payment_gateway_object, 'get_payment_processor_links') ? $payment_gateway_object->get_payment_processor_links() : new Tempcode();

    require_javascript('shopping');

    return array($fields, $hidden, $logos, $payment_processor_links);
}

/**
 * Get form fields for an address.
 *
 * @param  string $prefix The prefix for the address input field.
 * @param  string $street_address Street address.
 * @param  string $city Town/City.
 * @param  string $county County.
 * @param  string $state State.
 * @param  string $post_code Postcode/Zip.
 * @param  string $country Country.
 * @return Tempcode Address fields
 */
function get_address_fields($prefix, $street_address, $city, $county, $state, $post_code, $country)
{
    $fields = new Tempcode();

    $fields->attach(form_input_text(do_lang_cpf('street_address'), '', $prefix . 'street_address', $street_address, true));

    $fields->attach(form_input_line(do_lang_cpf('city'), '', $prefix . 'city', $city, true));

    if (get_option('cpf_enable_county') == '1') {
        $fields->attach(form_input_line(do_lang_cpf('county'), '', $prefix . 'county', $county, true));
    }

    if (get_option('cpf_enable_state') == '1') {
        $fields->attach(form_input_line(do_lang_cpf('state'), '', $prefix . 'state', $state, true));
    }

    $fields->attach(form_input_line(do_lang_cpf('post_code'), '', $prefix . 'post_code', $post_code, true, null, 12, 'text', null, null, null, 8));

    $countries = new Tempcode();
    $countries->attach(form_input_list_entry('', $country == ''));
    $countries->attach(create_region_selection_list(array($country)));
    $fields->attach(form_input_list(do_lang_cpf('country'), '', $prefix . 'country', $countries, null, false, true));

    return $fields;
}

/**
 * Attach a memo field to a product's input fields if needed.
 *
 * @param  ?Tempcode $fields The fields to attach to (null: create new Tempcode object if needed).
 */
function ecommerce_attach_memo_field_if_needed(&$fields)
{
    if (get_option('payment_memos') == '1') {
        if (perform_local_payment()) {
            $get_memo = true;
        } else {
            $payment_gateway = get_option('payment_gateway');
            require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
            $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);
            $config = $payment_gateway_object->get_config();
            $get_memo = !$config['supports_remote_memo'];
        }
        if ($get_memo) {
            if ($fields === null) {
                $fields = new Tempcode();
            }
            $fields->attach(form_input_text(do_lang_tempcode('NOTES'), do_lang_tempcode('TRANSACTION_NOTES'), 'memo', '', false));
        }
    }
}

/**
 * Get a CPF label, for re-use as a general form input label. Remove any CPF name prefixing.
 *
 * @param  ID_TEXT $cpf_name The CPF name.
 * @return string The CPF label
 */
function do_lang_cpf($cpf_name)
{
    require_lang('cns_special_cpf');

    $ret = do_lang('SPECIAL_CPF__cms_' . $cpf_name);
    $ret = preg_replace('#.*: #', '', $ret);
    return $ret;
}

/**
 * Handle a particular local transaction as determined by the POST request.
 *
 * @param  ID_TEXT $payment_gateway The payment gateway
 * @param  object $payment_gateway_object The payment gateway object
 * @return array A triple: success status, formatted status message, raw status message
 */
function do_local_transaction($payment_gateway, $payment_gateway_object)
{
    // Grab transaction details...

    $trans_expecting_id = post_param_string('trans_id');

    $transaction_rows = $GLOBALS['SITE_DB']->query_select('ecom_trans_expecting', array('*'), array('id' => $trans_expecting_id), '', 1);
    if (!array_key_exists(0, $transaction_rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE'));
    }
    $transaction_row = $transaction_rows[0];

    $type_code = $transaction_row['e_type_code'];
    $item_name = $transaction_row['e_item_name'];
    $purchase_id = $transaction_row['e_purchase_id'];

    $amount = $transaction_row['e_price'];
    $currency = $transaction_row['e_currency'];

    $length = $transaction_row['e_length'];
    $length_units = $transaction_row['e_length_units'];
    $is_subscription = ($length !== null);

    $memo = $transaction_row['e_memo'];

    $cardholder_name = post_param_string('payment_cardholder_name');
    $card_type = post_param_string('payment_card_type', '');
    $card_number = post_param_string('payment_card_number');
    $card_start_date = post_param_string('payment_card_start_date_year') . '/' . post_param_string('payment_card_start_date_month');
    $card_expiry_date = post_param_string('payment_card_expiry_date_year') . '/' . post_param_string('payment_card_expiry_date_month');
    $card_issue_number = post_param_integer('payment_card_issue_number', null);
    $card_cv2 = post_param_string('payment_card_cv2');

    // Read billing address

    $billing_street_address = post_param_string('billing_street_address', '');
    $billing_city = post_param_string('billing_city', '');
    $billing_county = post_param_string('billing_county', '');
    $billing_state = post_param_string('billing_state', '');
    $billing_post_code = post_param_string('billing_post_code', '');
    $billing_country = post_param_string('billing_country', '');

    // Save shipping address for order...

    $shipping_firstname = post_param_string('shipping_firstname', '');
    $shipping_lastname = post_param_string('shipping_lastname', '');
    $shipping_street_address = post_param_string('shipping_street_address', '');
    $shipping_city = post_param_string('shipping_city', '');
    $shipping_county = post_param_string('shipping_county', '');
    $shipping_state = post_param_string('shipping_state', '');
    $shipping_post_code = post_param_string('shipping_post_code', '');
    $shipping_country = post_param_string('shipping_country', '');
    $shipping_email = post_param_string('shipping_email', '');
    $shipping_phone = post_param_string('shipping_phone', '');
    if (addon_installed('shopping')) {
        if (preg_match('#^CART_ORDER_#', $type_code) != 0) {
            $shipping_address = array(
                'a_order_id' => intval($purchase_id),
                'a_firstname' => $shipping_firstname,
                'a_lastname' => $shipping_lastname,
                'a_street_address' => $shipping_street_address,
                'a_city' => $shipping_city,
                'a_county' => $shipping_county,
                'a_state' => $shipping_state,
                'a_post_code' => $shipping_post_code,
                'a_country' => $shipping_country,
                'a_email' => $shipping_email,
                'a_phone' => $shipping_phone,
            );
            $GLOBALS['SITE_DB']->query_insert('shopping_order_addresses', $shipping_address, true);
        }
    }

    // Save into CPFs...

    if ((get_param_integer('payment_save_to_account', 0) == 1) && (get_forum_type() == 'cns') && (get_option('store_credit_card_numbers') == '1')) {
        require_code('cns_members_action2');
        $changes = array();
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_payment_cardholder_name'), $cardholder_name, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_payment_card_type'), $card_type, null, true);
        //$changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_payment_card_number'), $card_number, null, true);   PCI rules mean we can't save this without encrypting it and obfuscating when displayed; too onerous to force encryption keys that aren't backed up, so let's save everything but this
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_payment_card_start_date'), $card_start_date, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_payment_card_expiry_date'), $card_expiry_date, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_payment_card_issue_number'), $card_issue_number, null, true);
        if (count($changes) != 0) {
            $GLOBALS['FORUM_DB']->query_update('f_member_custom_fields', $changes, array('mf_member_id' => get_member()), '', 1);
        }
    }

    if ((get_param_integer('billing_save_to_account', 0) == 1) && (get_forum_type() == 'cns') && (get_option('store_credit_card_numbers') == '1')) {
        require_code('cns_members_action2');
        $changes = array();
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_billing_street_address'), $billing_street_address, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_billing_city'), $billing_city, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_billing_county'), $billing_county, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_billing_state'), $billing_state, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_billing_post_code'), $billing_post_code, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_billing_country'), $billing_country, null, true);
        if (count($changes) != 0) {
            $GLOBALS['FORUM_DB']->query_update('f_member_custom_fields', $changes, array('mf_member_id' => get_member()), '', 1);
        }
    }

    if ((get_param_integer('shipping_save_to_account', 0) == 1) && (get_forum_type() == 'cns') && (get_option('store_credit_card_numbers') == '1')) {
        require_code('cns_members_action2');
        $changes = array();
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_firstname'), $shipping_firstname, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_lastname'), $shipping_lastname, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_street_address'), $shipping_street_address, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_city'), $shipping_city, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_county'), $shipping_county, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_state'), $shipping_state, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_post_code'), $shipping_post_code, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_country'), $shipping_country, null, true);
        $changes += cns_set_custom_field(get_member(), find_cms_cpf_field_id('cms_mobile_phone_number'), $shipping_phone, null, true);
        if (count($changes) != 0) {
            $GLOBALS['FORUM_DB']->query_update('f_member_custom_fields', $changes, array('mf_member_id' => get_member()), '', 1);
        }
    }

    // Process order...

    list($success, $message, $message_raw, $txn_id) = $payment_gateway_object->do_local_transaction($trans_expecting_id, $cardholder_name, $card_type, $card_number, $card_start_date, $card_expiry_date, $card_issue_number, $card_cv2, $amount, $currency, $billing_street_address, $billing_city, $billing_county, $billing_state, $billing_post_code, $billing_country, $shipping_firstname, $shipping_lastname, $shipping_street_address, $shipping_city, $shipping_county, $shipping_state, $shipping_post_code, $shipping_country, $shipping_email, $shipping_phone, $length, $length_units);

    if (($success) || ($length !== null)) {
        $status = (($length !== null) && (!$success)) ? 'SCancelled' : 'Completed';
        $period = ($length === null) ? '' : strtolower(strval($length) . ' ' . $length_units);
        list(, $member_id) = handle_confirmed_transaction($trans_expecting_id, $txn_id, $type_code, $item_name, $purchase_id, $is_subscription, $status, $message_raw, $amount, $currency, '', '', $memo, $period, get_member(), $payment_gateway);
    }

    // Return...

    if (is_numeric($message)) {
        // Not usable
        $message = null;
    }

    return array($success, $message, $message_raw);
}

/**
 * Handle IPN's.
 *
 * @return ID_TEXT The ID of the purchase-type (meaning depends on item_name)
 */
function handle_ipn_transaction_script()
{
    if ((file_exists(get_file_base() . '/data_custom/ecommerce.log')) && (is_writable_wrap(get_file_base() . '/data_custom/ecommerce.log'))) {
        $myfile = fopen(get_file_base() . '/data_custom/ecommerce.log', 'at');
        flock($myfile, LOCK_EX);
        fseek($myfile, 0, SEEK_END);
        fwrite($myfile, serialize($_POST) . "\n");
        fwrite($myfile, serialize($_GET) . "\n");
        fwrite($myfile, "\n\n");
        flock($myfile, LOCK_UN);
        fclose($myfile);
    }

    $payment_gateway = get_param_string('from', get_option('payment_gateway'));
    require_code('hooks/systems/payment_gateway/' . filter_naughty_harsh($payment_gateway));
    $payment_gateway_object = object_factory('Hook_payment_gateway_' . $payment_gateway);

    ob_start();

    list($trans_expecting_id, $txn_id, $type_code, $item_name, $purchase_id, $is_subscription, $status, $reason, $amount, $currency, $parent_txn_id, $pending_reason, $memo, $period, $member_id) = $payment_gateway_object->handle_ipn_transaction();

    list($type_code, $member_id) = handle_confirmed_transaction($trans_expecting_id, $txn_id, $type_code, $item_name, $purchase_id, $is_subscription, $status, $reason, $amount, $currency, $parent_txn_id, $pending_reason, $memo, $period, $member_id, $payment_gateway);

    if (method_exists($payment_gateway_object, 'show_payment_response')) {
        echo $payment_gateway_object->show_payment_response($type_code, $purchase_id);
    }

    return $purchase_id;
}

/**
 * Handle IPN's that have been confirmed as backed up by real money.
 * Variables largely emulate PayPal's IPN API.
 *
 * @param  ?ID_TEXT $trans_expecting_id Our internal temporary transaction ID (null: an immediate transaction that didn't require this table)
 * @param  ID_TEXT $txn_id The transaction ID
 * @param  ID_TEXT $type_code The product codename
 * @param  SHORT_TEXT $item_name The human-readable product title (blank: doing a subscription cancellation, unknown item name; but can get from $found)
 * @param  ID_TEXT $purchase_id The ID of the purchase-type (meaning depends on item_name)
 * @param  boolean $is_subscription Whether this is a subscription
 * @param  ID_TEXT $status The status this transaction is telling of
 * @set    Pending Completed SModified SCancelled
 * @param  SHORT_TEXT $reason A reason for the transaction's status (blank: unknown or N/A)
 * @param  ID_TEXT $amount Transaction amount (blank: unknown or doing a subscription cancellation or a free transaction triggered from somewhere other than a payment gateway)
 * @param  ID_TEXT $currency The currency the amount is in (points: was done fully with points)
 * @param  ID_TEXT $parent_txn_id The ID of the parent transaction (blank: unknown or N/A)
 * @param  SHORT_TEXT $pending_reason The reason it is in pending status (if it is) (blank: unknown or N/A)
 * @param  LONG_TEXT $memo A note attached to the transaction (blank: not set)
 * @param  string $period The subscription period (blank: N/A or unknown because trust is checked on the gateway's code)
 * @param  ?MEMBER $member_id_paying The member ID of who is doing the transaction (null: unknown)
 * @param  ID_TEXT $payment_gateway The payment gateway (manual: was a manual transaction, not through a real gateway)
 * @return array ID_TEXT A pair: The product purchased, The purchasing member ID (or null)
 */
function handle_confirmed_transaction($trans_expecting_id, $txn_id, $type_code, $item_name, $purchase_id, $is_subscription, $status, $reason, $amount, $currency, $parent_txn_id, $pending_reason, $memo, $period, $member_id_paying, $payment_gateway)
{
    // Try and locate the product
    if ($is_subscription) { // Subscription
        // Find what we sold
        list($found, , $product_object) = find_product_details($type_code);

        // Check subscription length
        if ($period != '') {
            $length = array_key_exists('length', $found['type_special_details']) ? strval($found['type_special_details']['length']) : '1';
            $length_units = array_key_exists('length_units', $found['type_special_details']) ? $found['type_special_details']['length_units'] : 'm';
            if (strtolower($period) != strtolower($length . ' ' . $length_units)) {
                fatal_ipn_exit(do_lang('IPN_SUB_PERIOD_WRONG'));
            }
        }
    } else {
        // Find what we sold
        list($found, $type_code, $product_object) = find_product_details($type_code);

        if ($found['type'] == PRODUCT_SUBSCRIPTION) {
            exit(); // We ignore separate payment signal for subscriptions (for Paypal it is web_accept). Or, it could be a hacker, which we must block
        }
    }
    if ($found === null) {
        fatal_ipn_exit(do_lang('PRODUCT_NO_SUCH', $item_name));
    }

    // Missing data, but we can find it
    if ($item_name == '') {
        $item_name = $found['item_name'];
    }

    // Find which member the transaction was for, if we can (otherwise we leave it as who did the transaction, or null if that's not set)
    $member_id = $member_id_paying;
    if (method_exists($product_object, 'member_for')) {
        $member_id = $product_object->member_for($type_code, $purchase_id);
    } else {
        if ($member_id === null) {
            if ($found['type'] == PRODUCT_SUBSCRIPTION) {
                $member_id = $GLOBALS['SITE_DB']->query_select_value_if_there('ecom_subscriptions', 's_member_id', array('id' => intval($purchase_id)));
            }
            elseif ($found['type'] == PRODUCT_INVOICE) {
                $member_id = $GLOBALS['SITE_DB']->query_select_value_if_there('ecom_invoices', 'i_member_id', array('id' => intval($purchase_id)));
            }
        }
    }
    if ($member_id == $GLOBALS['FORUM_DRIVER']->get_guest_id()) {
        $member_id = null;
    }
    if ($member_id_paying === null) {
        $member_id_paying = $member_id;
    }

    // Invoice: Check price
    if (($amount != '') && ($currency != 'points')) {
        if ($found['type'] == PRODUCT_INVOICE) {
            $price = $GLOBALS['SITE_DB']->query_select_value('ecom_invoices', 'i_amount', array('id' => intval($purchase_id)));
            if ($price != $amount) {
                if ($payment_gateway != 'manual') {
                    fatal_ipn_exit(do_lang('PURCHASE_WRONG_PRICE', $item_name, $amount, $price));
                }
            }
        }
    }

    // What is expected
    $expected_price = $found['price'];
    $expected_currency = isset($found['currency']) ? $found['currency'] : get_option('currency');
    $expected_price_points = null;
    if ($trans_expecting_id !== null) {
        $transaction_rows = $GLOBALS['SITE_DB']->query_select('ecom_trans_expecting', array('*'), array('id' => $trans_expecting_id), '', 1);
        if ((array_key_exists(0, $transaction_rows)) && (time() - $transaction_rows[0]['e_time'] < 24 * 60 * 60 * intval(get_option('ecom_price_honour_time')))) {
            $transaction_row = $transaction_rows[0];
            $expected_price = $transaction_row['e_price'];
            $expected_currency = $transaction_row['e_currency'];
            $expected_price_points = $transaction_row['e_price_points'];
        }
    }

    // Check price, if one defined (non-invoices)
    if ($found['type'] != PRODUCT_INVOICE) {
        if (($amount != '') && ($currency != 'points'/*payment gateway will never claim points, so we know we can skip this check branch for points transactions as we did the call manually*/)) {
            if (($expected_price_points === null) && (($expected_price === null) || (floatval($amount) != floatval($expected_price)))) {
                // No pre-calculated points charge, and no full price defined or not paid full price - so we need to work out the price split...
                // (this code branch rarely runs, as payment gateway transactions have the pre-calculated charges)

                $given_discount = false;

                // Consider points as a discount (if was 100% paid via points then ($currency == 'points') would have stopped the branch running, and we would have already charged the points in purchase.php)
                if ($member_id_paying !== null) {
                    list($discounted_price, $points_for_discount) = get_discounted_price($found, false, $member_id_paying);
                    if (($discounted_price !== null) && (floatval($amount) == $discounted_price)) {
                        require_code('points2');
                        charge_member($member_id_paying, $points_for_discount, do_lang('DISCOUNTED_ECOMMERCE_PRODUCT', $item_name));
                        $given_discount = true;
                    }
                }

                if (!$given_discount) {
                    if (($status == 'Completed') && ($payment_gateway != 'manual')) {
                        fatal_ipn_exit(do_lang('PURCHASE_WRONG_PRICE', $item_name, $amount, ($expected_price === null) ? do_lang('NA') : $expected_price), $is_subscription);
                    }
                }
            } elseif (($expected_price_points !== null) && ($expected_price_points !== 0)) {
                // Pre-calculated points charge that is non-zero...

                require_code('points2');
                charge_member($member_id_paying, $expected_price_points, do_lang('DISCOUNTED_ECOMMERCE_PRODUCT', $item_name));
            }
        }
    }

    // Check currency
    if (($amount != '') && ($currency != 'points'/*payment gateway will never claim points, so we know we can skip this check branch for points transactions as we did the call manually*/)) {
        if ($currency != $expected_currency) {
            if (($status != 'SCancelled') && ($payment_gateway != 'manual')) {
                fatal_ipn_exit(do_lang('PURCHASE_WRONG_CURRENCY', $item_name, $currency, $expected_currency));
            }
        }
    }

    // Store
    $GLOBALS['SITE_DB']->query_insert('ecom_transactions', array(
        'id' => $txn_id,
        't_memo' => $memo,
        't_type_code' => $type_code,
        't_purchase_id' => $purchase_id,
        't_status' => $status,
        't_pending_reason' => $pending_reason,
        't_reason' => $reason,
        't_amount' => $amount,
        't_currency' => $currency,
        't_parent_txn_id' => $parent_txn_id,
        't_time' => time(),
        't_payment_gateway' => $payment_gateway,
    ));

    // Add in extra details to $found, so actualisers can track things better
    $found['TXN_ID'] = $txn_id;
    $found['STATUS'] = $status;

    // Pending: We do some book-keeping then stop
    if ($status == 'Pending') {
        $found['ORDER_STATUS'] = 'ORDER_STATUS_awaiting_payment';

        if ($found['type'] == PRODUCT_INVOICE) { // Invoices have special support for tracking the order status
            $GLOBALS['SITE_DB']->query_update('ecom_invoices', array('i_state' => 'pending'), array('id' => intval($purchase_id)), '', 1);
        } elseif ($found['type'] == PRODUCT_SUBSCRIPTION) { // Subscriptions have special support for tracking the order status
            $GLOBALS['SITE_DB']->query_update('ecom_subscriptions', array('s_state' => 'pending'), array('id' => intval($purchase_id)), '', 1);
        }

        // Call actualiser code
        if (method_exists($found, 'actualiser')) {
            $product_object->actualiser($type_code, $purchase_id, $found);
        }

        // Pending transactions stop here
        fatal_ipn_exit(do_lang('TRANSACTION_NOT_COMPLETE', $type_code . ':' . strval($purchase_id), $status), true);
    }

    /*
    At this point we know our transaction is good -- or a subscription cancellation.
    Possible statuses: Completed|SModified|SCancelled
    */

    // Subscription: Completed (Made active)
    if (($status == 'Completed') && ($found['type'] == PRODUCT_SUBSCRIPTION)) {
        $GLOBALS['SITE_DB']->query_update('ecom_subscriptions', array('s_auto_fund_source' => $payment_gateway, 's_auto_fund_key' => $txn_id, 's_state' => 'active'), array('id' => intval($purchase_id)), '', 1);
    }

    // Subscription: Modified
    if (($status == 'SModified') && ($found['type'] == PRODUCT_SUBSCRIPTION)) {
        // No special action needed
    }

    // Subscription: Cancelled
    if (($status == 'SCancelled') && ($found['type'] == PRODUCT_SUBSCRIPTION)) {
        $GLOBALS['SITE_DB']->query_update('ecom_subscriptions', array('s_auto_fund_source' => $payment_gateway, 's_auto_fund_key' => $txn_id, 's_state' => 'cancelled'), array('id' => intval($purchase_id)), '', 1);
    }

    // Invoice handling
    if (($status == 'Completed') && ($found['type'] == PRODUCT_INVOICE)) {
        $GLOBALS['SITE_DB']->query_update('ecom_invoices', array('i_state' => 'paid'), array('id' => intval($purchase_id)), '', 1);
    }

    // Set order dispatch status
    if ($status == 'Completed') {
        if (!method_exists($product_object, 'get_product_dispatch_type')) { // If hook does not have dispatch method setting take dispatch method as automatic
            $found['ORDER_STATUS'] = 'ORDER_STATUS_dispatched';
        } elseif ($product_object->get_product_dispatch_type($purchase_id) == 'automatic') {
            $found['ORDER_STATUS'] = 'ORDER_STATUS_dispatched';
        } else {
            $found['ORDER_STATUS'] = 'ORDER_STATUS_payment_received'; // Dispatch has to happen manually still
        }
    }

    // Call actualiser code
    if (method_exists($product_object, 'actualiser')) {
        $automatic_setup = $product_object->actualiser($type_code, $purchase_id, $found);
    } else {
        $automatic_setup = false;
    }

    // Notifications
    if ($status == 'Completed') {
        if ($member_id !== null) {
            require_code('notifications');

            if ($currency == 'points') {
                $_currency = do_lang('POINTS');
            } else {
                $_currency = $currency;
            }

            // Send completed notification to user
            $subject = do_lang('PAYMENT_SENT_SUBJECT', $txn_id, $item_name, null, get_lang($member_id));
            $body = do_notification_lang($automatic_setup ? 'PAYMENT_SENT_BODY_automatic' : 'PAYMENT_SENT_BODY_manual', float_format(floatval($amount)), $_currency, array(get_site_name(), $item_name), get_lang($member_id));
            dispatch_notification('payment_received', null, $subject, $body, array($member_id), A_FROM_SYSTEM_PRIVILEGED);

            // Send completed notification to staff
            $subject = do_lang('PAYMENT_RECEIVED_SUBJECT', $txn_id, $item_name, null, get_site_default_lang());
            $body = do_notification_lang('PAYMENT_RECEIVED_BODY', float_format(floatval($amount)), $_currency, array(($memo == '') ? do_lang('NONE') : $memo, $item_name), get_site_default_lang());
            dispatch_notification('payment_received_staff', null, $subject, $body, array($member_id), A_FROM_SYSTEM_PRIVILEGED);
        }
    }

    // Cleanup very old data
    $GLOBALS['SITE_DB']->query('DELETE FROM ' . get_table_prefix() . 'ecom_sales_expecting WHERE e_time<' . strval(time() - 60 * 60 * 24 * 90));

    return array($type_code, $member_id);
}

/**
 * Exit Composr and write to the error log file.
 *
 * @param  string $error The message.
 * @param  boolean $dont_trigger Dont trigger an error
 * @return mixed Never returns (i.e. exits)
 */
function fatal_ipn_exit($error, $dont_trigger = false)
{
    echo $error . "\n";
    if (!$dont_trigger) {
        trigger_error($error, E_USER_NOTICE);
    }
    exit();
}

/**
 * Find the 'discounted' price for a product (check the return values carefully).
 *
 * @param  array $details Product details.
 * @param  boolean $consider_free Consider the potential for a 0.0 price by paying entirely with points.
 * @param  ?MEMBER $member_id The member who this is for (null: current member).
 * @return array A triple Discounted price as a float (null is no discount), Points required to get discount (null is no discount), Whether this is a discount
 */
function get_discounted_price($details, $consider_free = false, $member_id = null)
{
    if ((!addon_installed('points')) || (is_guest())) {
        return array(
            null,
            null,
            false
        );
    }

    if ($member_id === null) {
        $member_id = get_member();
    }

    if (($consider_free) && ($details['price_points'] !== null)) {
        require_code('points');
        if ((available_points($member_id) >= $details['price_points']) || ($details['price'] === null/*has to be points as no monetary-price*/) || (has_privilege($member_id, 'give_points_self'))) {
            return array(
                0.0,
                $details['price_points'],
                false
            );
        }
    }

    if (($details['discount_points__num_points'] !== null) && ($details['discount_points__price_reduction'] !== null) && ($details['price'] !== null)) {
        require_code('points');
        if ((available_points($member_id) >= $details['discount_points__num_points']) || (has_privilege($member_id, 'give_points_self'))) {
            return array(
                max(0.0, floatval($details['price']) - floatval($details['discount_points__price_reduction'])),
                $details['discount_points__num_points'],
                true
            );
        }
    }

    return array(
        null,
        null,
        false
    );
}
